// A COMPRENDRE

let map := new Object
map["\\e"] := epsilon
map["Îµ"]   := epsilon

// converts an automaton into a JSON object
// look at unitTests.ajs examples for more information
export function automaton2json(A)
    function toString(e)
        if e = epsilon then
            return "\\\\e"
        end if

        return JSON.stringify(aude.elementToString(e, map))
    end function

    let finalStates := A.getFinalStates()
    let states      := A.getStates()
    let transitions := A.getTransitions()
    let q_init      := A.getInitialState()
    let result      := "{\n\t\"states\": [" + toString(q_init)
    let began       := false


    foreach state in states do
        if state != q_init and finalStates does not contain state then
            result += "," + toString(state)
        end if
    done

    result += "],\n\t\"finalStates\": ["

    foreach state in finalStates do
        if began then
            result += ","
        else
            began := true
        end if
        result += toString(state)
    done

    result += "],\n\t\"transitions\": ["
    began  := false

    foreach transition in transitions do
        if began then
            result += ","
        else
            began := true
        end if

        result += "\n\t\t[" + toString(transition.startState) + "," + toString(transition.symbol) + "," + toString(transition.endState) + "]"
    done

    return result + "\n\t]\n}"
end function

// takes a JSON object like the ones in unitTests.ajs
// and converts them into an automaton (JS object)
export function object2automaton(o)
    let A := new Automaton

    // we rename the function aude.getValue
    let fromString := aude.getValue            //il fait quoi fromString?????????????????????????

    for i from 0 to o.states.length - 1 do
        if i = 0 then
            A.setInitialState(fromString(o.states[i], map))
        else
            // we add states to the automaton
            A.addState(fromString(o.states[i], map))
        end if
    done

    // we add the final states to the automaton
    foreach s in o.finalStates do
        A.addFinalState(fromString(s, map))
    done

    // we add the transitions to the automaton
    // to see the method, go to js/automaton.js
    foreach t in o.transitions do
        A.addTransition(
            fromString(t[0], map),
            fromString(t[1], map),
            fromString(t[2], map)
        )
    done

    return A
end function

run(automaton2json, get_automaton(currentAutomaton))


// takes a JSON object like the ones in unitTests.ajs
// and converts them into a mealy/moore machine(JS object)
export function object2mealymoore(o,isMealy)

    let M := (
        if isMealy then
            new Mealy()
        else
            new Moore()
    )

    let fromString := aude.getValue

    foreach s in o.states do
        // we add states to the automaton
        //M.states.add(fromString(o.states[i], map))
        M.addState(s)
    done

    //M.initial_state := o.initial_state
    M.initialState(o.initialState)


    foreach i in o.inputAlph do
        //M.input_alphabet.add(fromString(o.inputAlph[i], map))
        M.addInAlphabet(i)
    done

    foreach i in o.outputAlph do
        //M.output_alphabet.add(fromString(o.outputAlph[i], map))
        M.addOutAlphabet(i)
    done

    // we add the transitions to the mealy machine
    //M.transition := new Map()
    foreach t in o.transitions do
        M.addTransition(t[0],t[1],t[2])
    done

    // we add the outputs to the machine
    //M.output := new Map()
    foreach p in o.outputs do
        if isMealy then // Mealy case
            M.addOutput(p[0],p[1],p[2])
        else // Moore case
            M.addOutput(p[0],p[1])
        end if
    done
    return M
end function

export function object2mealy (o)
    return object2mealymoore (o, true)
end function

export function object2moore (o)
    return object2mealymoore(o, false)
end function

