let map := new Object
map["\\e"] := epsilon
map["Îµ"]   := epsilon

# Converts an automaton into a JSON object
export function automaton2json(A)
    function toString(e)
        if e = epsilon then
            return "\\\\e"
        end if

        return JSON.stringify(aude.elementToString(e, map))
    end function

    let finalStates := A.getFinalStates()
    let states      := A.getStates()
    let transitions := A.getTransitions()
    let q_init      := A.getInitialState()
    let result      := "{\n\t\"states\": [" + toString(q_init)
    let began       := false


    foreach state in states do
        if state != q_init and finalStates does not contain state then
            result += "," + toString(state)
        end if
    done

    result += "],\n\t\"finalStates\": ["

    foreach state in finalStates do
        if began then
            result += ","
        else
            began := true
        end if
        result += toString(state)
    done

    result += "],\n\t\"transitions\": ["
    began  := false

    foreach transition in transitions do
        if began then
            result += ","
        else
            began := true
        end if

        result += "\n\t\t[" + toString(transition.startState) + "," + toString(transition.symbol) + "," + toString(transition.endState) + "]"
    done

    return result + "\n\t]\n}"
end function

# Takes a JSON object and converts it into an automaton
export function object2automaton(o)
    let A := new Automaton

    let fromString := aude.getValue

    for i from 0 to o.states.length - 1 do
        if i = 0 then
            A.setInitialState(fromString(o.states[i], map))
        else
            A.addState(fromString(o.states[i], map))
        end if
    done

    foreach s in o.finalStates do
        A.addFinalState(fromString(s, map))
    done

    foreach t in o.transitions do
        A.addTransition(
            fromString(t[0], map),
            fromString(t[1], map),
            fromString(t[2], map)
        )
    done

    return A
end function

# Takes an object and converts it into a Mealy / Moore machine
export function object2mealymoore(o, isMealy)
    let M := (
        if isMealy then
            new Mealy()
        else
            new Moore()
    )

    let fromString := aude.getValue

    foreach s in o.states do
        M.addState(s)
    done

    M.setInitialState(o.initialState)

    foreach i in o.inputAlph do
        M.addInputSymbol(i)
    done

    foreach i in o.outputAlph do
        M.addOutputSymbol(i)
    done

    foreach t in o.transitions do
        M.addTransition(t[0], t[1], t[2])
    done

    foreach p in o.outputs do
        if isMealy then
            M.setOutput(p[0], p[1], p[2])
        else
            M.setOutput(p[0], p[1])
        end if
    done
    return M
end function

export function object2mealy (o)
    return object2mealymoore (o, true)
end function

export function object2moore (o)
    return object2mealymoore(o, false)
end function

run(automaton2json, get_automaton(currentAutomaton))
