include determinization;
include completion;

function minimize(A, isAlreadyDeterminized, isAlreadyDeterminizedAndComplete, alphabet) {

  // before minimizing, automaton must be determinist and complete.
  if(!isAlreadyDeterminized && !isDeterminized(A)) {
     A = determinize(A);
  }
  if(!isAlreadyDeterminizedAndComplete) {
     A = complete(A, alphabet);
  }

  MinA : Automaton;
  let trans = A.getTransitionFunction();
  
  // we make a partition of the states ; accepting and non accepting states are separated
  partition : Set of Set;
  
  foreach(q1 in A.getStates()) {
    foreach(q2 in A.getStates()) {
      if(A.isAcceptingState(q1) === A.isAcceptingState(q2))
        partition.add([q1, q2]); // we add the set {q1, q2} to partition
    }
  }
  
  oldCard : Integer;
  found1 : bool;
  found2 : bool;
  
  copyPartition : Set of Set;
  do {
    oldCard = partition.card();
    copyPartition = partition.copy();
    l  : List;
    q1 : State;
    q2 : State;
  
    foreach(couple in copyPartition) {
      l  = couple.getList();
      q1 = l[0];
      q2 = l[l.length-1];
      
      foreach(a in trans(q1) union trans(q2)) {
        foreach(qq1 in trans(q1, a)) {
          foreach(qq2 in trans(q2, a)) {
            if(copyPartition.contains([q1, qq1]) !== copyPartition.contains([q2, qq2])) {
              partition.remove(couple);
              break;
            }
          }
        }
      }
    }
  }
  while(partition.card() !== oldCard);
  
  remainingStates : Set of State;
  
  function addState(q) {
    if(!remainingStates.contains(q)) {
      remainingStates.add(q);
      if(q belongsTo trans()) {
        foreach(symbol in trans(q)) {
          foreach(state in trans(q, symbol)) {
            addState(state);
          }
        }
      }
    }
  }
  
  addState(A.getInitialState());
  
  accepting : bool;
  
  s : Integer = 0;
  newStates : List;
  oldStates : List;
  while(remainingStates.card()) {
    let l = remainingStates.getList();
    newStates[s] = new Set();
    newStates[s].add(l[0]);
    oldStates[l[0]] = s;
    accepting = false;
    remainingStates.remove(l[0]);
    if(A.isAcceptingState(l[0]))
      accepting = true;
    foreach(i in {1,...,l.length-1}) {
      if(partition.contains([l[0], l[i]])) {
        newStates[s].add(l[i]);
        oldStates[l[i]] = s;
        remainingStates.remove(l[i]);
        if(!accepting && A.isAcceptingState(l[i])) {
          accepting = true;
        }
      }
    }
    MinA.addState(newStates[s]);
    if(accepting)
      MinA.setAcceptingState(newStates[s]);
    if(newStates[s].contains(A.getInitialState()))
      MinA.setInitialState(newStates[s]);
    ++s;
  }
  
  foreach(t in A.getTransitions()) {
    if(t.startState in oldStates && t.endState in oldStates)
      MinA.addTransition(newStates[oldStates[t.startState]], t.symbol, newStates[oldStates[t.endState]]);
  }
  
  return MinA;
}

run(minimize, get_automaton(currentAutomaton));