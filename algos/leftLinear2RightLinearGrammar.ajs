//Convert a left linear grammar to a right linear grammar
//G can be a string or a grammar class
//if str is 1 the function returns a string
//if str is 0 the fonction returns a grammar
export function leftLinear2RightLinearGrammar (G,str)
    if typeof G = "string" then
        G := string2LinearGrammar(G)
    end if
    if G=undefined or isLeftLinear(G)=false then
        return G
    end if

    let GL := new linearGrammar() //The new right linear grammar
    let finalSymbols := G.getTerminalSymbols()
    let nonFinalSymbols := G.getNonTerminalSymbols()
    let rules := new Set(G.getProductionRules()) //We copy it beacause we modify it later
    let axiom := G.getStartSymbol()


    foreach fs in finalSymbols do
        GL.addTerminalSymbol(fs)
    done

    foreach nfs in nonFinalSymbols do
        GL.addNonTerminalSymbol(nfs)
    done

    GL.setStartSymbol(axiom)

    //If there a rule axiom -> axiom finalSymbol then create S0 -> S and S0 is the new axiom
    let nameAxiom := "S0"
    foreach rule in rules do
        if rule.nonTerminalSymbol=axiom and rule.nonTerminalSymbolBody!="" and rule.nonTerminalSymbolBody!=undefined then
            while nameAxiom belongs to nonFinalSymbols do
                nameAxiom +='0'
            done
            GL.setStartSymbol(nameAxiom)
            rules.add(new Rule(nameAxiom,"",axiom))
            axiom := nameAxiom
            break;
        end if
    done

    //Add the production rules
    // Axiom -> p : Axiom -> p
    // Axiom -> Ap : A -> p
    // A -> p : Axiom -> pA
    // B -> Ap : A -> pB
    foreach rule in rules do
        if rule.getNonTerminalSymbol() = axiom and (rule.getNonTerminalSymbolBody()=undefined or rule.getNonTerminalSymbolBody()="") then
            GL.addRule(axiom,rule.getListSymbolTerminal())
        else if rule.getNonTerminalSymbol() = axiom then
            GL.addRule(rule.getNonTerminalSymbolBody(),rule.getListSymbolTerminal())
        else if rule.getNonTerminalSymbolBody() = undefined or rule.getNonTerminalSymbolBody() = "" then
            if rule.getListSymbolTerminal()="ε" then //if A -> ε then Axiom -> A
                GL.addRule(axiom,"",rule.getNonTerminalSymbol())
            else
                GL.addRule(axiom,rule.getListSymbolTerminal(),rule.getNonTerminalSymbol())
            end if
        else
            if rule.getListSymbolTerminal()="ε" then
                GL.addRule(rule.getNonTerminalSymbolBody(),"",rule.getNonTerminalSymbol())
            else
                GL.addRule(rule.getNonTerminalSymbolBody(),rule.getListSymbolTerminal(),rule.getNonTerminalSymbol())
            end if
        end if
    done

    if str=0 or str=undefined then
        return GL
    else
        return GL.toString()
    end if
end function


export function isLeftLinear(G)
    let rules := G.getProductionRules()
    foreach rule in rules do
        if rule.side="left" then
            return true
        end if
    done
end function


run (
    function ()
        let input := window.prompt(
            AudeGUI.l10n(
            "Enter the left linear grammar"
            ),
        )
    return leftLinear2RightLinearGrammar(input,1)

end function

)
