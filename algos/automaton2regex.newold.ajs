function automatonToRegularExpression(A, raw) {
   L : MappingFunction;
   let res = emptySet;
   let q_init = A.getInitialState();


   // A regular expression is a set of parts of regular expressions.
   // e = a_1+...+a_i is represented as {a_1,...,a_i}

   // returns a string representation of the regular expression e
   function string(e, parenthesis) {
      if(e instanceof Set) {
         // sum

         let s = '';
         let forbidEpsilon = e.card() !== 1;
         let eps = REEpsilon();
         let c = 0;
         foreach(p in e) {
            if(!forbidEpsilon || p != eps) {
               s += (s ? '+' : '')  + string(p);
               ++c;
            }
         }
         parenthesis = parenthesis && c > 1;
         return (parenthesis ? '(' : '') + s + (parenthesis ? ')' : '');
      }
      else {
         switch(e.type) {
            case 'epsilon':
               return 'ε';
            case 'symbol':
               return Set.prototype.elementToString(e.value);
            case 'cat':
               return (parenthesis > 1 ? '(' : '') +
                      string(e.value1, 1) + '·' + string(e.value2, 1) +
                      (parenthesis > 1 ? ')' : '');
            case 'star':
               return string(e.value, 2) + '*';
         }
      }
   }

   // compute the star of a regular expression
   function star(re) {
     console.log("star", Set.prototype.elementToString(re));
      switch(re.type) {
         case 'epsilon':
         case 'star':
            return re;
         default:
            if(re == emptySet) {
               return re;
            }
            else if(re == {REEpsilon()}) {
              console.log("TRUE");
               return REEpsilon();
            }
            else {
               return {
                  type:'star',
                  value:re
               };
            }
      }
   }

   // concatenates two regular expressions
   function bicat(r1, r2) {
     console.log('cat', Set.prototype.elementToString(r1), Set.prototype.elementToString(r2));
      if(!(r1 instanceof Set)) {
         r1 = {r1};
      }
      
      if(!(r2 instanceof Set)) {
         r2 = {r2};
      }

      let epsSet = {REEpsilon()};

      if(r1 == emptySet || r2 == emptySet) {
         return emptySet;
      }

      if(r1 == epsSet) {
        if(r2 == epsSet) {
           return REEpsilon(); 
        }
        return r2;
      }

      if(r2 == epsSet) {
         if(r1 == epsSet) {
            return REEpsilon(); 
         }
         return r1;
      }

      let res = emptySet;

      foreach(RE1 in r1) {
         foreach(RE2 in r2) {
           if(RE1.type == 'epsilon') {
              res.add(RE2);
           }
           else if(RE2.type == 'epsilon') {
              res.add(RE1);
           }
           else {
             res.add({
                type:'cat',
                value1:RE1,
                value2:RE2
             });
           }
         }
      }
      if(res == epsSet) {
        return REEpsilon();
      }
      return res;
   }

   // concatenates three regular expressions
   function cat(r1,r2,r3) {
      return bicat(r1, bicat(r2, r3));
   }

   // makes a part of regular expression from a symbol
   function symbol(a) {
      return {
         type:'symbol',
         value: a
      };
   }

   // returns the epsilon part of a regular expression
   function REEpsilon() {
      return {
         type:'epsilon'
      };
   }

   // removes the state s
   function remove(s) {
      foreach(p in A.getStates()) {
         foreach(q in A.getStates()) {
            L([p,p], L([p,p]) union cat(L([p,s]), star(L([s,s])), L([s, p])));
            L([q,q], L([q,q]) union cat(L([q,s]), star(L([s,s])), L([s, q])));
            L([p,q], L([p,q]) union cat(L([p,s]), star(L([s,s])), L([s, q])));
            L([q,p], L([q,p]) union cat(L([q,s]), star(L([s,s])), L([s, p])));
         }
      }
   }


   /* Initialization : */

   foreach(p in A.getStates()) {
      foreach(q in A.getStates()) {
         if(p === q) {
            // We map each (i,i) to the epsilon regular expression
            L([p,q], {REEpsilon()});
         }
         else {
            // We maps each (p,q) p ≠ q to the empty regular expression
            L([p,q], emptySet);
         }
      }
   }

   /* Basis : for each (p,q) in Q², for each symbol a such that (p,a,q) is a transition, we map (p,q) to the regular expression a */
   foreach(t in A.getTransitions()) {
     L([t.startState, t.endState], L([t.startState, t.startState]) union {symbol(t.symbol)});
   }

   /* State removal : we remove each state which is not final nor initial */
   foreach(q in A.getStates()) {
      if(q !== q_init && q !belongsTo A.getFinalStates()) {
         remove(q);
      }
   }

   foreach(f in A.getFinalStates()) {
      res.add(
         cat (
            star(L([q_init,q_init])),
            L([q_init,f]),
            star(
               cat(
                  L([f,q_init]),
                  star(L([q_init,q_init])),
                  L([q_init,f]) union L([f,f])
               )
            )
         )
      );
   }
   console.log(Set.prototype.elementToString(res));
   return raw ? res : string(res);
}

run(automatonToRegularExpression, get_automaton(currentAutomaton), false);