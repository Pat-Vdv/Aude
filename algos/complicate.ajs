from mutate import addState, addTransitionFromState, randomNumber, addEpsilonTransitionToState, addEpsilonTransitionFromState, getRandomElement, newStateName
from coreachability import coreachableStates

# Adds a not reachable state to the automaton
export function addNotReachable(A)
    let stateName := newStateName(A)
    addState(A, stateName)
    var random := randomNumber(1, 4)
    var i := 0
    while i < random do
        addTransitionFromState(A, stateName)
        i++
    done
end function

# Adds a random transition between two not co-reachable states
export function transitionNotCoreachable(A)
    # extraction of not co-reachable states from the automaton
    let coreachStates := coreachableStates(A)
    let states := A.getStates()
    let notcoreachStates := states \ coreachStates

    # we can only add a transition if there is a state.
    if notcoreachStates.size > 0 then
        let randomNotCoaState1 := getRandomElement(notcoreachStates)
        let randomNotCoaState2 := getRandomElement(notcoreachStates)
        let randomSymbol := getRandomElement(A.getAlphabet(), "a")

        A.addTransition(randomNotCoaState1, randomSymbol, randomNotCoaState2)
    end if
end function

# Adds a random transition that goes to a not co-reachable state
export function addTransitionToANotCoreachable(A)
    # extraction of not co-reachable states from the automaton
    let coreachStates := coreachableStates(A)
    let states := A.getStates()
    let notcoreachStates := states \ coreachStates

    if notcoreachStates.size > 1 then
        let randomNotCoaState := getRandomElement(notcoreachStates)
        let randomState       := getRandomElement(states)
        let randomSymbol      := getRandomElement(A.getAlphabet(), "a")
        A.addTransition(randomState, randomSymbol, randomNotCoaState)
    end if

    return A
end function

# Adds states and transitions to the automaton by copying certain states and
# transitions in the original automaton to complicate it thus resulting in a
# non deterministic finite state automaton
export function copyTransitions(A)
    if A.getTransitions() is empty then
        return
    end if

    let f := A.getTransitionFunction()

    # we take a random transition instead of a state
    # just in case the automaton isn't complete
    let randomTransition := getRandomElement(A.getTransitions())
    let startState := randomTransition.startState
    let symbol     := randomTransition.symbol
    let endState   := randomTransition.endState

    let random := randomNumber(1, A.getStates().size)
    let i := 0
    # we should be careful in case we're forced to enter the loop
    # and the automaton can't give us any transitions
    while i < random do
        let newState := newStateName(A)
        # we add a new state we're copying is final
        # then the newState will be final too
        # this way the langage the automaton recognizes doesn't change
        A.addState(newState)

        if A.getFinalStates() contains endState then
            A.addFinalState(newState)
        end if

        # we connect an existant state to the new state
        # by copying an existent transition
        A.addTransition(startState, symbol, newState)

        if (f(endState).getItem()) = undefined then
            i := random
        else
            symbol     := f(endState).getItem()
            endState   := f(endState, symbol).getItem()
            startState := newState

            i++
        end if
    done

    A.addTransition(startState, symbol, endState)
    return A
end function

run(
    function (A)
        var input := window.prompt(
            AudeGUI.l10n(
                "Complicate the current automaton by choosing one or more of the following options\n1 - Add a non reachable state\n2 - Add a transition between two non co-reachable states\n3 - Add a transition to a non co-reachable state\n4 - Copy transitions"
            ),
            "1 3 4"
        )

        # extracting from input the set of numbers separated by commas/spaces/anything_else_that's_not_a_number
        let I := []
        var n := 0
        foreach c in input do
            if c <= '9' and c >= '0' then
                n:= n * 10 + parseInt(c)
            else
                I.push(n)
                n := 0
            end if
        done

        if n !=0 then
            I.push(n)
        end if

        # for each case we execute the associated function
        foreach c in I do
           if c = 1 then
               addNotReachable(A)
           else if c = 2 then
               transitionNotCoreachable(A)
           else if c = 3 then
               addTransitionToANotCoreachable(A)
           else if c = 4 then
               copyTransitions(A)
           end if
        end foreach
        return A
    end function,
    get_automaton(currentAutomaton)
)
