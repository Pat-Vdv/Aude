# Create a random automaton

from mutate import randomNumber
from reachability import reachableStates
from coreachability import coreachableStates


// Ask the value to create an automaton
// activate the function validate
function askSettingsAutomaton(validate)
    let div := document.createElement("div");
    div.className := "libD-ws-colors-auto auto-size";

    div.appendChild(libD.jso2dom([
        AutomatonPrograms.tableRandomAutomateGeneration(),
        ["div", {"style": "text-align:right"}, ["button#validate-automaton", _("Validate")]]
    ]));

    let win := libD.newWin({ // Create a new window
        title:      _("Settings automaton"),
        show:       true,
        fullscreen: false,
        content: div
    });

    // Validate the choice
    document.getElementById("validate-automaton").onclick := (function ()
        let inputs := document.getElementsByClassName("input-settings-question");
        let alphabet := inputs[1].value.split(",");
        let access := (
            if inputs[5].checked and inputs[6].checked then
                1
            else if (not inputs[5].checked) and inputs[6].checked then
                2
            else if inputs[5].checked and not inputs[6].checked then
                3
            else
                0
        )

        validate(inputs[0].value, alphabet, inputs[2].value, inputs[3].value, inputs[4].value, acces);
    end function)
end function


# Take:
#  - a number of states
#  - an alphabet
#  - a number of final states
#  - the type (1: Determinist, 2: No determinist, 3: Epsilon-transition),
#  - a number of transitions (number or low, medium, high)
export function createAutomaton(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    let A := new Automaton

    if typeAutomaton = 1 and nbTransitions > nbStates * alphabet.length then
        return (
            "Too much transitions. The maximum number is: " +
                (nbStates * alphabet.length) +
            " and you requested: " + nbTransitions
        );
    else if typeAutomaton = 2 and nbTransitions > nbStates * nbStates * alphabet.length then
        return (
            "Too much transitions. The maximum number is: " + (
                nbStates * nbStates * alphabet.length
            ) + " and you requested: " + nbTransitions
        );
    else if typeAutomaton = 3 and nbTransitions > nbStates * nbStates * (alphabet.length + 1) then
        return (
            "Too much transitions. The maximum number is: " + (
                nbStates * nbStates * (alphabet.length + 1)
            ) + " and you requested: " + nbTransitions
        )
    else if nbStates < nbAcceptingStates then
        return "You requested more accepting states than states"
    end if

    # Initialize the alphabet
    foreach symbol in alphabet do
        A.addSymbol(symbol)
    done

    # Creation of states
    for i from 1 to nbStates do
        A.addState(i)
    done

    # Set an initial state
    A.setInitialState(randomNumber(1, nbStates))

    # Set final states
    let rand := randomNumber(1, nbStates)
    for i from 1 to nbAcceptingStates do
        while rand belongs to A.getFinalStates() do
            rand := randomNumber(1, nbStates)
        done
         A.setFinalState(rand)
    done

    # Create transitions
    if typeAutomaton=1 then
        A := createTransitionDeterminist(A, alphabet, nbStates, nbTransitions)
    else if typeAutomaton=2 then
        A := createTransitionNonDeterminist(A, alphabet, nbStates, nbTransitions)
    else if typeAutomaton=3 then
        A := createTransitionEpsilon(A, alphabet, nbStates, nbTransitions)
    end if

    return A
end function

# Create the transistions for a determinist automata
function createTransitionDeterminist(A, alphabet, nbStates, nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1, nbStates)
            state2 := randomNumber(1, nbStates)
            sym := alphabet[randomNumber(0, alphabet.length-1)]
            # Add a transition that doesn't exist
        while A.hasTransition(state1, sym, state2) or otherTransition(A, state1, sym)

        A.addTransition(state1, sym, state2)
    done
    return A
end function

# Create the transistions for a non-determinist automaton
function createTransitionNonDeterminist(A, alphabet, nbStates, nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1, nbStates)
            state2 := randomNumber(1, nbStates)
            sym := alphabet[randomNumber(0, alphabet.length-1)]
            # Add a transition that doesn't exist
        while A.hasTransition(state1, sym, state2)
        A.addTransition(state1, sym, state2)
    done
    return A
end function

# Create the transistions for a epsilon-transitions automaton
function createTransitionEpsilon(A, alphabet, nbStates, nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    let num := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1, nbStates)
            state2 := randomNumber(1, nbStates)
            num := randomNumber(0, alphabet.length)
            if num = alphabet.length then
                sym := epsilon
            else
                sym := alphabet[num]
            end if
            # Add a transition that doesn't exist
        while A.hasTransition(state1, sym, state2)
        A.addTransition(state1, sym, state2)
    done
    return A
end function

# Takes an automaton, a state, a symbol and returns true if there is a transition
# which starts from the state and symbol given
function otherTransition(A, state, symbol)
    foreach states in A.getStates() do
        if A.hasTransition(state, symbol, states) then
            return true
        end if
    done
    return false
end function

# Return true if all states are reachable
function allStateReachable(A)
    let b := reachableStates(A)
    return b.size = A.getStates().size
end function

# Return true if all states are co-reachable
function allStateCoreachable(A)
    let b := coreachableStates(A)
    return b.size = A.getStates().size
end function

# Create an automaton where all states are reachable and co-reachable
export function createAutomatonCoreachable(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    let A := null

    if nbStates - 1 > nbTransitions then
        return "Can't create the automaton where all the states are reachable and co-reachable"
    end if

    do
        A := createAutomaton(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    while typeof A != "string" and ( not allStateReachable(A) or not allStateCoreachable(A) )

    return A
end function

# Create an automaton where all states are co-reachable
function createAutomatonCoacces(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    let A := null

    if nbStates-1 > nbTransitions then
        return "Can't create the automaton where all the states are co-reachable"
    end if

    do
        A := createAutomaton(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    while typeof A != "string" and not allStateCoreachable(A)
    return A
end function

# Create an automaton where all states are reachable
function createAutomatonAccess(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    let A := null
    if nbStates-1 > nbTransitions then
        return "Can't create the automaton where all the states are reachable"
    end if
    do
        A := createAutomaton(nbStates, alphabet, nbAcceptingStates, typeAutomaton, nbTransitions)
    while typeof A != "string" and not allStateReachable(A)
    return A
end function

run(
    function()
        function accept(states, alphabet, finalStates, type, transitions, acces)
            if acces = 1 then
                AudeGUI.Results.set(
                    createAutomatonCoreachable(
                        states,
                        alphabet,
                        finalStates,
                        type,
                        transitions
                    )
                )
            else if acces = 2 then
                AudeGUI.Results.set(
                    createAutomatonCoacces(
                        states,
                        alphabet,
                        finalStates,
                        type,
                        transitions
                    )
                )
            else if acces = 3 then
                AudeGUI.Results.set(
                    createAutomatonAccess(
                        states,
                        alphabet,
                        finalStates,
                        type,
                        transitions
                    )
                )
            else if acces = 0 then
                AudeGUI.Results.set(
                    createAutomaton(
                        states,
                        alphabet,
                        finalStates,
                        type,
                        transitions
                    )
                )
            fi
        end function
        askSettingsAutomaton(accept)
    end function
)
