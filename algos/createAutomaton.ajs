# Create  hazardly an automaton

from mutate import randomNumber
from accessibility import accessibleStates
from coaccessibility import coaccessibleStates


# Take a number of states, an alphabet, a number of final states, the type (1: Determinist
# 2: No determinist 3:E psilon-transition), a number of transitions (number or low, medium, high)
export function createAutomaton(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    let A := new Automaton

    if typeAutomaton=1 and nbTransitions > nbStates*alphabet.length then
        return "Too much transitions: the maximum number is: "+nbStates*alphabet.length+" and you asked: "+ nbTransitions
    else if typeAutomaton=2 and nbTransitions > nbStates*nbStates*alphabet.length then
        return "Too much transitions: the maximum number is: "+nbStates*nbStates*alphabet.length+" and you asked: "+ nbTransitions
    else if typeAutomaton=3 and nbTransitions > nbStates*nbStates*(alphabet.length+1) then
        return "Too much transitions: the maximum number is: "+nbStates*nbStates*(alphabet.length+1)+" and you asked: "+ nbTransitions
    else if nbStates<nbFinalStates then
        return "You asked more final states than states"
    end if

    # Initialize the alphabet
    foreach symbol in alphabet do
        A.addSymbol(symbol)
    done

    # Creation of states
    for i from 1 to nbStates do
        A.addState(i)
    done

    # Set an initial state
    A.setInitialState(randomNumber(1,nbStates))

    # Set final states
    let rand := randomNumber(1,nbStates)
    for i from 1 to nbFinalStates do
        while rand belongs to A.getFinalStates() do
            rand := randomNumber(1,nbStates)
        done
         A.setFinalState(rand)
    done

    # Create transitions
    if typeAutomaton=1 then
        A := createTransitionDeterminist(A,alphabet,nbStates,nbTransitions)
    else if typeAutomaton=2 then
        A := createTransitionNonDeterminist(A,alphabet,nbStates,nbTransitions)
    else if typeAutomaton=3 then
        A := createTransitionEpsilon(A,alphabet,nbStates,nbTransitions)
    end if

    return A
end function

# Create the transistions for a determinist automata
function createTransitionDeterminist(A,alphabet,nbStates,nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1,nbStates)
            state2 := randomNumber(1,nbStates)
            sym := alphabet[randomNumber(0,alphabet.length-1)]
        # Add a transition that doesn't exist
        while A.hasTransition(state1,sym,state2) or otherTransition(A,state1,sym)
        A.addTransition(state1,sym,state2)
    done
    return A
end function

# Create the transistions for a non-determinist automaton
function createTransitionNonDeterminist(A,alphabet,nbStates,nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1,nbStates)
            state2 := randomNumber(1,nbStates)
            sym := alphabet[randomNumber(0,alphabet.length-1)]
        while A.hasTransition(state1,sym,state2) # Add a transition that doesn't exist
        A.addTransition(state1,sym,state2)
    done
    return A
end function

# Create the transistions for a epsilon-transitions automaton
function createTransitionEpsilon(A,alphabet,nbStates,nbTransitions)
    let transitions := null
    let state1 := null
    let state2 := null
    let sym := null
    let num := null
    for i from 1 to nbTransitions do
        transitions := A.getTransitions()
        do
            state1 := randomNumber(1,nbStates)
            state2 := randomNumber(1,nbStates)
            num := randomNumber(0,alphabet.length)
            if num = alphabet.length then
                sym := epsilon
            else
                sym := alphabet[num]
            end if
        while A.hasTransition(state1,sym,state2)  # Add a transition that doesn't exist
        A.addTransition(state1,sym,state2)
    done
    return A
end function

# Takes an automaton, a state, a symbol and returns true if there is a transition
# which starts from the state and symbol given
function otherTransition(A,state,symbol)
    foreach states in A.getStates() do
        if A.hasTransition(state,symbol,states) then
            return true
        end if
    done
    return false
end function

# Return true if all states are accessible
function allStateAccessible(A)
    let b := accessibleStates(A)
    return b.size = A.getStates().size
end function

# Return true if all states are co-accessible
function allStateCoaccessible(A)
    let b := coaccessibleStates(A)
    return b.size = A.getStates().size
end function

# Create an automaton where all states are accessible and coaccessible
export function createAutomatonCoaccessible(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    let A := null
    if nbStates-1 > nbTransitions then
        return "Can't create the automaton where all the states are accessible and coaccessible"
    end if
    do
        A := createAutomaton(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    while typeof A != "string" and ( not allStateAccessible(A) or not allStateCoaccessible(A) )
    return A
end function

# Create an automaton where all states are coaccessible
function createAutomatonCoacces(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    let A := null
    if nbStates-1 > nbTransitions then
        return "Can't create the automaton where all the states are coaccessible"
    end if
    do
        A := createAutomaton(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    while typeof A != "string" and not allStateCoaccessible(A)
    return A
end function

# Create an automaton where all states are accessible
function createAutomatonAccess(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    let A := null
    if nbStates-1 > nbTransitions then
        return "Can't create the automaton where all the states are accessible"
    end if
    do
        A := createAutomaton(nbStates,alphabet,nbFinalStates,typeAutomaton,nbTransitions)
    while typeof A != "string" and not allStateAccessible(A)
    return A
end function

run(
    function()
        function accept(states,alphabet,finalStates,type,transitions,acces)
            if acces = 1 then
                AudeGUI.Results.set(createAutomatonCoaccessible(states,alphabet,finalStates,type,transitions))
            else if acces = 2 then
                AudeGUI.Results.set(createAutomatonCoacces(states,alphabet,finalStates,type,transitions))
            else if acces = 3 then
                AudeGUI.Results.set(createAutomatonAccess(states,alphabet,finalStates,type,transitions))
            else if acces = 0 then
                AudeGUI.Results.set(createAutomaton(states,alphabet,finalStates,type,transitions))
            fi
        end function
        askSettingsAutomaton(accept)


    end function
)
