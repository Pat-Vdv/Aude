from minimization import minimize
from normalization import normalize

# Implementation using path equations technique ("équations aux chemins")

let epsilonRE := {"type":"epsilon"}
let emptyRE   := {"type":"void"}

function symbol(s)
    return {"type":"symbol", "v1":s}
end function

function plusRE(newSet)
    let c := newSet.card()

    if c = 0 then
        return emptyRE
    end if

    if c = 1 then
        return newSet.getItem()
    end if

    return {"type":"+", "v1":newSet}
end function

function star(e)
    if e.type = "void" then
        return epsilonRE
    end if

    if e.type = "*" or e = epsilonRE then
        return e
    end if

    if e.type = "+" and e.v1 contains epsilonRE then
        return star(plusRE(e.v1 minus {epsilonRE}))
    end if

    return {"type":"*", "v1":e}
end function

function add(e1, e2)
    if e1 = emptyRE or e1 = e2 then
        return e2
    end if

    if e2 = emptyRE then
        return e1
    end if

    if e1.type = "+" and e2.type = "+" then
        return plusRE(e1.v1 union e2.v1)
    end if

    return {"type":"+", "v1":{e1, e2}}
end function

function cat(e1, e2)
    if e1 = emptyRE or e2 = emptyRE then
        return emptyRE
    end if

    if e1 = epsilonRE then
        return e2
    end if

    if e2 = epsilonRE then
        return e1
    end if

    return {"type":".", "v1":e1, "v2":e2}
end function


function string(e)
    if e = epsilonRE then
        return "ε"
    else if e = emptyRE then
        return "ø"
    else if e.type = "symbol" then
        return e.v1
    else if e.type = "+" then
        let l := e.v1.getSortedList()
        let res := ""

        foreach e in l do
            if res != "" then
                res += " + "
            end if
            res += string(e)
        done
        return res
    else if e.type = "." then
        let s1 := string(e.v1)
        let s2 := string(e.v2)

        if e.v1.type = "+" then
            s1 := "(" + s1 + ")"
        end if

        if e.v2.type = "+" then
            s2 := "(" + s2 + ")"
        end if

        return s1 + s2
    else if e.type = "*" then
        if e.v1.type = "symbol" then
            return string(e.v1) + "*"
        end if
        return "(" + string(e.v1) + ")*"
    end if

    # Should not happen
    return e.type + "(" + string(e.v1) + ", " + string(e.v2) + ")"
end function

export function automatonToRE(A, retStruct)
    A := normalize(minimize(A), 1)
    let trans := A.getTransitionFunction()

    function R(k, i, j)
        if k = 0 then
            let e := (
                if i = j then
                    epsilonRE
                else
                    emptyRE
            )

            foreach s in trans(i) do
                if trans(i, s) contains j then
                    e := add(e, symbol(s))
                fi
            done
            return e
        end if

        return (
            add(
                R(k - 1, i, j),
                cat(
                    R(k - 1, i, k),
                    cat(
                        star(R(k - 1, k, k)),
                        R(k - 1, k, j)
                    )
                )
            )
        )
    end function

    let res := emptyRE

    let n := A.getStates().card()

    foreach f in A.getAcceptingStates() do
        res := add(res, R(n, 1, f))
    done

    return (
        if retStruct then
            res
        else
            string(res)
    )
end function

run(
    function (A)
        function replaceSpecialChars(s)
            return (
                s.replace(/\(/g, "\\left(")
                   .replace(/\)/g, "\\right)")
                   .replace(/\*/g, "\\text{*}")
                   .replace(/∅|ø/g, "\\emptyset ")
                   .replace(/ε/g, "\\varepsilon ")
            )
        end function

        let res := automatonToRE(A)

        if this.katex then
            let span := document.createElement("span")

            katex.render(
                "\\mathrm{" + (
                    replaceSpecialChars(res)
                ) + "}",
                span,
                {"throwOnError": false, "display": true}
            )

            return span
        else if this.MathJax then
            let span := document.createElement("span")

            span.textContent := (
                "$$\\rm{" + (
                    replaceSpecialChars(res)
                ) + "}$$"
            )

            MathJax.Hub.Queue(["Typeset", MathJax.Hub, span])

            return span
        end if

        return res
    end function,
    get_automaton(currentAutomaton)
)
