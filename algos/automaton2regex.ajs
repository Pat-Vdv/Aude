from minimization import minimize
from normalization import normalize

# Implementation using path equations technique ("équations aux chemins")

function RE(type, v1, v2)
    this.type := type or "void"
    this.v1 := v1
    this.v2 := v2
end function


function symbol(s)
    return new RE("symbol", s)
end function


function star(e)
    if e.type = "void" or (e.type = "symbol" and e.v1 = epsilon) then
        return e
    end if

    if e.type = "+" then
        if e.v1.type = "symbol" and e.v1.v1 = epsilon then
            return star(e.v2)
        end if

        if e.v2.type = "symbol" and e.v2.v1 = epsilon then
            return star(e.v1)
        end if
    end if

    return new RE("*", e)
end function


function add(e1, e2)
    if e1.type = "void" then
        return e2
    end if

    if e2.type = "void" then
        return e1
    end if

    return new RE("+", e1, e2)
end function


function cat(e1, e2)
    if e1.type = "void" or e2.type = "void" then
        return new RE
    end if

    if e1.type = "symbol" and e1.v1 = epsilon then
        return e2
    end if

    if e2.type = "symbol" and e2.v1 = epsilon then
        return e1
    end if

    return new RE(".", e1, e2)
end function


function string(e)
    if e.type = "symbol" then
        return (
            if e.v1 = epsilon then
                "ε"
            else
                e.v1
        )
    else if e.type = "+" then
        return string(e.v1) + "+" + string(e.v2)
    else if e.type = "." then
        let s1 := string(e.v1)
        let s2 := string(e.v2)

        if e.v1.type = "+" then
            s1 := "(" + s1 + ")"
        end if

        if e.v2.type = "+" then
            s2 := "(" + s2 + ")"
        end if

        return s1 + s2
    else if e.type = "*" then
        if e.v1.type = "*" then
            return string(e.v1)
        else if e.v1.type = "symbol" then
            return string(e.v1) + "*"
        else
            return "(" + string(e.v1) + ")*"
        end if
    else if e.type = "void" then
        return "ø"
    end if

    # Should not happen
    return e.type + "(" + string(e.v1) + ", " + string(e.v2) + ")"
end function


export function automatonToRE(A, retStruct)
    A := normalize(minimize(A), 1)
    let trans := A.getTransitionFunction()

    function R(k, i, j)
        if k = 0 then
            let e := (
                if i = j then
                    symbol(epsilon)
                else
                    new RE
            )

            foreach s in trans(i) do
                if trans(i, s) contains j then
                    e := add(e, symbol(s))
                fi
            done
            return e
        end if

        return (
            add(
                R(k - 1, i, j),
                cat(
                    R(k - 1, i, k),
                    cat(
                        star(R(k - 1, k, k)),
                        R(k - 1, k, j)
                    )
                )
            )
        )
    end function

    let res := new RE

    let n := A.getStates().card()

    foreach f in A.getAcceptingStates() do
        res := add(res, R(n, 1, f))
    done

    return (
        if retStruct then
            res
        else
            string(res)
    )
end function

run(
    function (A)
        function replaceSpecialChars(s)
            return (
                s.replace(/\(/g, "\\left(")
                   .replace(/\)/g, "\\right)")
                   .replace(/\*/g, "\\text{*}")
                   .replace(/∅|ø/g, "\\emptyset ")
                   .replace(/ε/g, "\\varepsilon ")
            )
        end function

        let res := automatonToRE(A)

        if this.katex then
            let span := document.createElement("span")

            katex.render(
                "\\mathrm{" + (
                    replaceSpecialChars(res)
                ) + "}",
                span,
                {"throwOnError": false, "display": true}
            )

            return span
        else if this.MathJax then
            let span := document.createElement("span")

            span.textContent := (
                "$$\\rm{" + (
                    replaceSpecialChars(res)
                ) + "}$$"
            )

            MathJax.Hub.Queue(["Typeset", MathJax.Hub, span])

            return span
        end if

        return res
    end function,
    get_automaton(currentAutomaton)
)
