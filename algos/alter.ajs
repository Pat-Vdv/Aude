from normalization import normalize

// Returns a random whole number in the [minimum, maximum] interval
export function randomNumber (minimum, maximum)
    var n := Math.floor((Math.random()) * (maximum - minimum + 1)) + minimum
    return n
end function

// This function returns a random symbol
// from the alphabet of an automaton
// the alphabet is a set
export function getRandomSymbol(alphabet)
    var random := randomNumber(1, alphabet.size)
    var i := 1
    foreach a in alphabet do
        if i = random then
            return a
        else
            i++
        end if
    end foreach
end function

// Returns a random state from the states set of an automaton
export function getRandomState(states)
    var random := randomNumber(1, states.size)
    var i := 1
    foreach state in states do
        if i = random then
            return state
        else
            i++
        end if
    end foreach
end function

// Returns a random transition from a set of transitions
export function getRandomTransition (transitions)
    var random := randomNumber(1, transitions.size)
    var i := 1
    foreach transition in transitions do
        if i = random then
            return transition
        else
            i++
        end if
    end foreach

end function

// Finds a name for a new state
// in the automaton and makes sure this state name doesn't already exist
export function getStateName(A)
    let stateName := A.getStates().size
    while stateName belongs to A.getStates() do
        stateName := parseInt(stateName) + 1
    done
    return stateName
end function


// Changes the symbol of a random transition in A
export function changeSymbol(A)
    // we choose a random transition of the automaton A
    var randomTransition := getRandomTransition(A.getTransitions())

    // we choose a random symbol from the alphabet of A
    // different from the symbol of randomTransition
    var randomSymbol := getRandomSymbol(A.getAlphabet())
    while randomSymbol = randomTransition.symbol do
         randomSymbol := getRandomSymbol(A.getAlphabet())
    done

    A.removeTransition(randomTransition)
    A.addTransition(randomTransition.startState, randomSymbol, randomTransition.endState)

    return A
end function

// Removes a random transition from the automaton
export function removeTransition(A)

    var randomTransition := getRandomTransition(A.getTransitions())
    A.removeTransition(randomTransition)
    return A

end function

// Adds a random false transition in the automaton
export function addTransition(A)
    // we choose a random input from the alphabet of A
    let randomInput := getRandomSymbol(A.getAlphabet())

    // we choose two random states of A
    let firstRandomState := getRandomState(A.getStates())
    let secondRandomState := getRandomState(A.getStates())

    // we add the new transition to A
    A.addTransition(firstRandomState, randomInput, secondRandomState)

    return A
end function

// Adds a random transition that starts at startState
export function addTransitionFromState(A, startState)
    let randomSymbol := getRandomSymbol(A.getAlphabet())
    let randomState := getRandomState(A.getStates())
    A.addTransition(startState, randomSymbol, randomState)
    return A
end function

// Adds an epsilon transition that starts at startState
export function addEpsilonTransitionFromState(A, startState)
    var randomState := getRandomState(A.getStates())
    A.addTransition(startState, epsilon.toString(), randomState)
    return A
end function

// Adds a random transition that arrives at endState
export function addTransitionToState(A, endState)
    var randomSymbol := getRandomSymbol(A.getAlphabet())
    var randomState := getRandomState(A.getStates())
    A.addTransition(randomState, randomSymbol, endState)
    return A
end function

// Adds an epsilon transition transition that arrives at endState
export function addEpsilonTransitionToState(A, endState)
    var randomState := getRandomState(A.getStates())
    A.addTransition(randomState, epsilon.toString(), endState)
    return A
end function


// Adds a new state to an automaton
export function addState(A, stateName)
    if stateName = undefined then
        let stateName := A.getStates().size
    end if

    A.addState(stateName)

    return A
end function

// Adds a new state and new transitions towards and from this state
export function addStateAndTransitions(A)
    var newState := getStateName(A)
    addState(A, newState)

    let random := randomNumber(1, 3)
    let i := 0
    while i < random do
        addTransitionToState(A, newState)
        i++
    done

    random := randomNumber(1,3)
    i:=0
    while i < random do
        addTransitionFromState(A, newState)
        i++
    done
    return A
end function

// REMARK : to add a new state and transitions to this state
// use addState(A, stateName) and addTransitionToState(A, stateName)

// Inverses a random transition of the automaton
export function inverseTransition(A)

    // if endState = startState then this function will not change the automaton
    // so we'll make sure to check the transition before inversing it

    // we put in the T set all the transitions that have a distinct startState and endState
    let T := new Set()
    foreach transition in A.getTransitions() do
        if transition.startState != transition.endState then
            T.add(transition)
        end if
    end foreach

    if T!={} then
        var randomTransition := getRandomTransition(T)
        A.removeTransition(randomTransition)
        A.addTransition(randomTransition.endState, randomTransition.symbol, randomTransition.startState)
    end if
    return A
end function

// Takes an automaton and returns another automaton identical to A missing a final state
export function removeFinalState(A)
    if A.getFinalStates() != {} then
        var randomFinalState := getRandomState(A.getFinalStates())
        A.toggleFinalState(randomFinalState)
    end if
        return A
end function

// If the automaton contains epsilon transitions
// then this function removes one of the epsilon transitions from the automaton
export function removeEpsilonTransition (A)
    // we count the number of epsilon transitions present in A
    var counter := 0
    foreach transition in A.getTransitions() do
        if transition.symbol = 'ε' then
            counter++
        end if
    end foreach

    if counter = 0 then
        return A // A has no epsilon transitions in this case
    end if

    // FIXME think about doing the other method where we store the epsilon transitions at
    // the beginning and then we won't have to go over all of the transitions twice

    var random := randomNumber(1, counter)
    var i := 1
    foreach transition in A.getTransitions() do
        if transition.symbol = 'ε' then
            if i = random then
                A.removeTransition(transition)
                return A
            else
                i++
            end if
        end if
    end foreach

end function

// Removes a state from the automaton that isn't the initial state
// and all the transitions towards this state
export function removeState(A)
    // removing a state randomly

    var removedState := getRandomState(A.getStates() \ {A.getInitialState()})
    A.removeState(removedState)

    // removing all the transitions that go towards removedState
    foreach transition in A.getTransitions() do
        if transition.endState = removedState then
            A.removeTransition(transition);
        end if
    end foreach
    return A
end function


// Transforms a random state into a final state
export function addFinal (A)
    var randomNonFinalState := getRandomState(A.getStates() \ A.getFinalStates())
    A.toggleFinalState(randomNonFinalState)
    return A
end function

run(
    function(A)
        var input := window.prompt("Transform the current automaton by choosing one or more of the following options\n1 - Change Symbol\n2 - Remove Transition\n3 - Add Transition\n4 - Add State And Transitions\n5 - Inverse Transition\n6 - Renumerate States\n7 - Remove Final State\n8 - Remove Epsilon Transition\n9 - Remove State\n10 - Add Final","2 1 10")

        // extracting from input the set of numbers separated by commas/spaces/anything_else_that's_not_a_number
        let I := []
        var n := 0
        foreach c in input do
            if c <= '9' and c >= '0' then
                n := n * 10 + parseInt(c)
            else
                I.push(n)
                n := 0
            end if
        done
        if n !=0 then
            I.push(n)
        end if

        // for each case we execute the associated function
        foreach c in I do
           if c = 1 then
               A := changeSymbol(A)
           else if c = 2 then
               A := removeTransition(A)
           else if c = 3 then
               A := addTransition(A)
           else if c = 4 then
               A := addStateAndTransitions(A)
           else if c = 5 then
               A := inverseTransition(A)
           else if c = 6 then
               A := normalize(A)
           else if c = 7 then
               A := removeFinalState(A)
           else if c = 8 then
               A := removeEpsilonTransition(A)
           else if c = 9 then
               A := removeState(A)
           else if c = 10 then
               A := addFinal(A)
           end if
        end foreach
        return A
    end function,
    get_automaton(currentAutomaton)
)

