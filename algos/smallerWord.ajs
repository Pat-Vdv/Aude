from emptyLanguage import emptyLanguage

//Return the smallest word recognized by A
export function smallerWord(A)

    if emptyLanguage(A)=true then
        return "No word recognized!"
    end if


    let initialState := A.getInitialState()
    let dist := new Object() //The distance from the initial state
    let word := new Object() //The little word from the initialState
    let P := {}
    let states := A.getStates()

    foreach s in states do //Initialise the values
        dist[s] := Infinity
        word[s] := ""
    done
    dist[initialState] := 0

    while states \ P is not empty do //While we did not visited all the states
        let minS := (states \ P).keys().next().value //Get a value
        //Get the state with the minimum dist[minS]
        foreach s in states \ P do
            if dist[s] < dist[minS] then
                minS := s
            fi
        done
        P.add(minS)

        foreach t in A.getTransitions() do
            if (minS = t.startState) then //For each state available by minS
                if t.symbol = epsilon then
                    if dist[minS] < dist[t.endState] then
                        dist[t.endState] := dist[minS]
                         word[t.endState] := word[minS]
                    fi
                else
                    if dist[minS]+1 < dist[t.endState] then
                        dist[t.endState] := dist[minS]+1
                        word[t.endState] := word[minS] + t.symbol
                    fi
                fi
            fi
        done
    done

    let nearestFinalState := undefined
    foreach s in states do
        if A.isFinalState(s) and (nearestFinalState = undefined or dist[s] < dist[nearestFinalState]) then
          nearestFinalState := s
        fi
    done

    return word[nearestFinalState]
end function

run(
    function ()
        return smallerWord(get_automaton(currentAutomaton))
    end function
)
