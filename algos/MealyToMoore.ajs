
// initial_output is the output of the initial state for the Moore machine
// since it depends on the mealy machine, it is to be deetermined each time
// initial_output is an element of input_alphabet
export function mealy2moore ( mealy, initial_output)

     let M := new Moore()

     M.input_alphabet := mealy.input_alphabet
     M.output_alphabet := mealy.output_alphabet
     if initial_output = undefined then
         initial_output:="Îµ"
     end if
     M.initial_state := [mealy.initial_state,initial_output].join("")
     M.states := new Set()
     M.transition := new Map()
     M.output := new Map()

    // a set containing all the [next_state,output] couples
    // that we've deduced from the Mealy machine
    // they represent the new Moore machine states
    let ns_o_set := new Set()

    foreach s in mealy.states do
        foreach a in mealy.input_alphabet do
            var ns_o := mealy.next(s,a) // next() returns an array: [next_state, output]
            ns_o_set.add(ns_o)
            M.states.add(ns_o.join(""))
            M.output.set(ns_o.join(""), ns_o[1])
        done
    done

    // if the initial state has no transition coming towards it
    // then it is not present in the ns_o_set, nor is it a state for M
    if ns_o_set does not contain [mealy.initial_state,initial_output] then
        ns_o_set.add([mealy.initial_state,initial_output])
        M.states.add(M.initial_state)
        M.output.set(M.initial_state,initial_output)
    end if

    // now we add the new transitions
    foreach c in ns_o_set do
        foreach a in M.input_alphabet do
            var next_c := mealy.next(c[0], a)
            M.transition.set([c.join(""),a], next_c.join("") )
        done
    done

    return M

end function

run(mealy2moore, get_mealy(currentAutomaton))
























