// PLEASE DO NOT EDIT THIS FILE DIRECTLY. IT IS AUTOMATICALLY GENERATED BY A MAKEFILE.
/*kate: tab-width 4; space-indent on; indent-width 4; replace-tabs on; eol unix; */
/*
    Copyright (c) 2013-2014, Raphaël Jakse (Université Joseph Fourier)
    All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Université Joseph Fourier nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint indent: 4, nomen: true, ass: true, vars: true, evil: true, plusplus: true, eqeq: true, todo: true, bitwise: true */
/*jshint -W043 */
/*eslint no-eval:0, no-extend-native:0 */
// NEEDS automata.js, set.js

(function (pkg, that) {
    "use strict";

    pkg.l10n = that.libD && that.libD.l10n ? that.libD.l10n() : function (s) { return s; };

    pkg.toPureJS = function (str, opts) {
        return pkg.internals.parseStatements({
            lexer: new pkg.Lexer(str),
            includes: opts && opts.includesArray,
            jsFeatures: (opts && opts.jsFeatures) || pkg.jsFeatures
        });
    };
    pkg.utils = {
        copy: function (constraintedVariables) {
            return {type: constraintedVariables.type.copy(), consts: constraintedVariables.consts.copy()};
        },

        autoTrim: function (s) {
            var b = 0, l = s.length;
            while (b < l && " \t".indexOf(s[b]) !== -1) {
                ++b;
            }
            var e = l - 1;
            while (e > -1 && " \t".indexOf(s[e]) !== -1) {
                --e;
            }
            return s.substring(b, e + 1);
        }
    };

    var copy = pkg.utils.copy;


    function trySymbolArray(lexer, type, a, checkNoIdentifierCharAfter) {
        for (var i = 0, len = a.length; i < len; ++i) {
            if (lexer.eat(a[i], type, checkNoIdentifierCharAfter)) {
                return true;
            }
        }
        return false;
    }

    function trySymbolObject(lexer, o) {
        for (var s in o) {
            if (o.hasOwnProperty(s) && lexer.eat(s, o[s])) {
                return true;
            }
        }
        return false;
    }

    function parseUnsignedNumber(lexer) {
        var dotEncountered = false,
            begin = lexer.curPos();

        if (!lexer.end() && lexer.lookAhead() === "0") {
            lexer.nextChar();
            if (!lexer.end() && (lexer.lookAhead().toLowerCase() === "x")) {
                do {
                    lexer.nextChar();
                } while ("0123456789ABCDEF".indexOf(lexer.lookAhead().toUpperCase()) !== -1);
                lexer.registerSymbol(lexer.NUMBER, begin);
                return true;
            }
        }

        while (
            !lexer.end()
         && (
                "0123456789".indexOf(lexer.lookAhead()) !== -1
             || (!dotEncountered && lexer.lookAhead() === ".")
         )) {
            if (!dotEncountered) {
                dotEncountered =  lexer.lookAhead() === ".";
            }
            lexer.nextChar();
        }

        // TODO: checking if the number is correct (e.g: doesn't end with a dot)
        if (!lexer.end() && (lexer.lookAhead() === "e" || lexer.lookAhead() === "E")) {
            lexer.nextChar();
            if (!lexer.end() && (lexer.lookAhead() === "+" || lexer.lookAhead() === "-")) {
                lexer.nextChar();
            }
        }

        while (!lexer.end() && "0123456789".indexOf(lexer.lookAhead()) !== -1) {
            lexer.nextChar();
        }

        lexer.registerSymbol(lexer.NUMBER, begin);
        return true;
    }

    function tryString(lexer) {
        if (lexer.lookAhead() === "\"" || lexer.lookAhead() === "'") {
            var begin = lexer.curPos();
            var endChar = lexer.nextChar();

            while (!lexer.end() && lexer.lookAhead() !== endChar) {
                if (lexer.lookAhead() === "\\") {
                    lexer.nextChar();
                }

                lexer.nextChar();
            }

            lexer.nextChar();
            lexer.registerSymbol(lexer.STRING, begin);
            return true;
        }
        return false;
    }

    function tryWhitespace(lexer) {
        if (!(lexer.lookAhead().trim())) {
            var begin = lexer.curPos();

            do {
                lexer.nextChar();
            } while (!lexer.end() && !(lexer.lookAhead().trim()));

            lexer.registerSymbol(lexer.WHITESPACE, begin);
            return true;
        }
    }

    function trySlash(lexer) {
        if (lexer.lookAhead() === "/") {
            var begin = lexer.curPos();

            lexer.nextChar();

            if (!lexer.end() && lexer.lookAhead() === "/") {
                while (!lexer.end() && lexer.lookAhead() !== "\n") {
                    lexer.nextChar();
                }
                lexer.registerSymbol(lexer.WHITESPACE, begin);
            } else if (!lexer.end() && lexer.lookAhead() === "*") {
                do {
                    lexer.nextChar();
                } while (
                    !lexer.end(1)
                 && !(lexer.lookAhead() === "*" && lexer.lookAhead(1) === "/")
                );

                lexer.nextChar(1);
                lexer.registerSymbol(lexer.WHITESPACE, begin);
            } else {
                if (lexer.lastSignificantType & (
                        lexer.NUMBER
                      | lexer.VARIABLE
                      | lexer.CLOSEPAREN
                      | lexer.CLOSEBRACKET
                )) {
                    if (lexer.lookAhead() === "=") {
                        lexer.nextChar();
                    }
                    lexer.registerSymbol(lexer.OPERATOR, begin);
                    return true;
                }

                while (!lexer.end() && lexer.lookAhead() !== "/") {
                    if (lexer.lookAhead() === "\\") {
                        lexer.nextChar();
                    }
                    lexer.nextChar();
                }
                lexer.nextChar();
                while (!lexer.end() && "azertyuiopqsdfghjklmwxcvbn".indexOf(lexer.lookAhead().toLowerCase()) !== -1) {
                    lexer.nextChar();
                }
                lexer.registerSymbol(lexer.REGEX, begin);
            }

            return true;
        }
        return false;
    }

    function tryDot(lexer) {
        if (lexer.lookAhead() === ".") {
            if (!lexer.end(1) && "0123456789".indexOf(lexer.lookAhead(1)) !== -1) {
                return parseUnsignedNumber(lexer);
            }

            lexer.nextChar();
            lexer.registerSymbol(lexer.DOT);
            return true;
        }
        return false;
    }

    function tryNumber(lexer) {
        if ("0123456789".indexOf(lexer.lookAhead()) !== -1) {
            return parseUnsignedNumber(lexer);
        }
        return false;
    }

    function tryReservedKeyword(lexer) {
        return (
            trySymbolArray(lexer, lexer.INSTRUCTION, [
                "let",
                "const",
                "var",
                "new", "delete",
                "return", "throw", "catch", "finally",
                "break", "continue", "yield", "debugger",
                "in", "of",
                "if", "else",
                "do", "while", "foreach", "for",

                "function",
                "instanceof", "typeof",
                "try", "catch", "finally",
                "include", "export", "import",
                "switch", "case", "default",
                "with",
                "enum", "class", "interface"
            ], true) || trySymbolArray(lexer, lexer.RESERVED, [
                "false",
                "null",
                "this",
                "true",
                "super",
                "void",
                "public",
                "static",
                "extends",
                "package",
                "private",
                "protected",
                "implements"
            ], true)
        );
    }

    function tryPunctuation(lexer) {
        return trySymbolObject(lexer, {
            ")": lexer.CLOSEPAREN,
            "]": lexer.CLOSEBRACKET,
            "}": lexer.CLOSECURLY,
            "{": lexer.OPENBRACKET,
            "[": lexer.OPENBRACKET,
            "(": lexer.OPENBRACKET,
            ",": lexer.COMMASEMICOLON,
            ";": lexer.COMMASEMICOLON
        });
    }

    function tryOperator(lexer) {
        return trySymbolArray(lexer, lexer.OPERATOR, [
            "++", "--", "+=", "-=",
            "===", "==",
            "!==", "!=",
            ">>>=",
            "<<<", ">>>",
            "<<=", ">>=",
            "<<", ">>",
            "<=", ">=",
            "=>", // arrow functions
            "||", "&&",
            "&=", "|=", "*=", "%=", "^=",
            "&", "|", "*", "%", "^", "~",
            "?", ":", "=",
            "<", ">",
            "+", "-",
            "="
        ]) || trySymbolArray(lexer, lexer.ALPHA_OPERATOR, [
            "!contains", "!subsetof", "!elementof", "!belongsto", "!haskey", "!has",
            "contains", "subsetof", "elementof", "belongsto", "haskey",
            "!subsetOf", "!elementOf", "!belongsTo", "!hasKey",
            "subsetOf", "elementOf", "hasKey", "has",
            "!"
        ]);
    }

    function tryEndOfInput(lexer) {
        if (lexer.end()) {
            lexer.registerSymbol(lexer.END);
            return true;
        }
    }

    function tryIdentifier(lexer) {
        var begin = lexer.curPos();

        if (lexer.lookAhead().match(pkg.Lexer.identifierStartChar)) {
            do {
                lexer.nextChar();
            } while (!lexer.end() && lexer.lookAhead().match(pkg.Lexer.identifierPartChar));
            lexer.registerSymbol(lexer.VARIABLE, begin);
            return true;
        }
        return false;
    }

    pkg.Lexer = function (s) {
        this.lastSignificantType = this.END;
        this.type                = this.END;
        this.str                 = s;
        this.symbol              = "";
        this.i                   = 0;
    };

    pkg.Lexer.prototype = {
        lookAhead: function (count) {
            return this.str[this.i + (count || 0)];
        },

        eat: function (s, type, checkNoIdentifierCharAfter) {
            var len = s.length;
            if (this.str.substr(this.i, len) === s
                && (
                    !checkNoIdentifierCharAfter
                    || (
                        !this.str[this.i + len]
                        || !this.str[this.i + len].match(pkg.Lexer.identifierPartChar)
                    )
                )
            ) {
                var i = this.curPos();
                this.nextChar(len - 1);
                this.registerSymbol(type, i);
                return true;
            }
            return false;
        },

        nextChar: function (count) {
            this.i += count || 0;
            return this.str[this.i++];
        },

        end: function () {
            return this.i >= this.str.length;
        },

        curPos: function () {
            return this.i;
        },

        next: function () {
            return (
                tryEndOfInput(this)
             || tryPunctuation(this)
             || tryOperator(this)
             || tryReservedKeyword(this)
             || tryString(this)
             || tryWhitespace(this)
             || tryDot(this)
             || tryNumber(this)
             || trySlash(this)
             || tryIdentifier(this)
            );
        },

        nextSymbol: function (begin) {
            var type = this.type;
            this.next();

            if (begin && this.type === type) {
                this.symbol = this.str.substring(begin, this.curPos());
            }

            return this.symbol;
        },

        save: function () {
            var s = new pkg.Lexer();
            s.type = this.type;
            s.str = this.str;
            s.lastSignificantType = this.lastSignificantType;
            s.i = this.i;
            s.symbol = this.symbol;

            return s;
        },

        // prefer using the saved lexer directly instead of restoring this one from the new lexer.
        restore: function (s) {
            this.type                = s.type;
            this.lastSignificantType = s.lastSignificantType;
            this.i                   = s.i;
            this.symbol              = s.symbol;
        },

        registerSymbol: function (type, begin) {
            if (isNaN(begin)) {
                begin = this.curPos() - 1;
            }

            this.type = type;
            this.symbol = this.str.substring(begin, this.curPos());

            if (type === this.WHITESPACE) {
                var state = this.save();
                this.nextSymbol(begin);
                if (this.type !== this.WHITESPACE) {
                    this.restore(state);
                }
            } else {
                this.lastSignificantType = type;
                if (type === this.END) {
                    this.symbol = "";
                    return;
                }
            }
        },

        getWhite: function (ignoreOneSpace) {
            var state = this.save();
            this.nextSymbol();

            if (this.type === this.WHITESPACE) {
                if (ignoreOneSpace && this.symbol === " ") {
                    return "";
                }
                return this.symbol;
            }

            this.restore(state);
            return "";
        },

        isIdentifier: function (v) {
            if (v[0].match(pkg.Lexer.identifierStartChar)) {
                for (var i = 1; i < v.length; ++i) {
                    if (!v[1].match(pkg.Lexer.identifierPartChar)) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        },

        substring: function (a, b) {
            return this.str.substring(a, b);
        },

        END:            0,
        STRING:         2,
        WHITESPACE:     4,
        VARIABLE:       8,
        DOT:            16,
        REGEX:          32,
        NUMBER:         64,
        OPERATOR:       128,
        COMMASEMICOLON: 256,
        CLOSEPAREN:     1024,
        CLOSECURLY:     2048,
        OPENBRACKET:    4096,
        INSTRUCTION:    8192,
        CLOSEBRACKET:   16384,
        RESERVED:       32768,
        ALPHA_OPERATOR: 65536
    };

    if (!pkg.Lexer) {
        pkg.Lexer = {};
    }


    pkg.Lexer.identifierStartChar = /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]$/;

	pkg.Lexer.identifierPartChar = /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/;

    pkg.internals = {
        getExpression: function (context, newContext) {
            newContext.lexer = context.lexer;
            if (!newContext.hasOwnProperty("inForeach")) {
                newContext.inForeach = context.inForeach;
            }

            if(!newContext.hasOwnProperty("enforceReturnType")) {
                newContext.enforceReturnType = context.enforceReturnType;
            }

            newContext.jsFeatures = context.jsFeatures;

            return pkg.internals.parseStatement(newContext);
        },

        parseStatements: function (context) {
            if (!context.constraintedVariables) {
                context.constraintedVariables = {
                    type: new Set(),
                    consts: new Set()
                };
            }

            var lexer = context.lexer,
                res   = "",
                symbol,
                lexerBeforeSymbol = lexer.save();

            do {
                // we browse the code, expression by expression
                res += pkg.internals.parseStatement(context);

                // if no expression was parsed
                if (lexer.curPos() === lexerBeforeSymbol.curPos()) {
                    symbol = lexer.nextSymbol();
                    if (context.endSymbols && context.endSymbols.hasOwnProperty(symbol)) {
                        lexer.restore(lexerBeforeSymbol);
                        return res;
                    }
                    // surely a syntax error,
                    // we avoid an infinite loop by just reading a symbol as is
                    res += symbol;
                }

                lexerBeforeSymbol = lexer.save();
                symbol = lexerBeforeSymbol.nextSymbol();

                // if we saw a stop symbol
                if (context.endSymbols && context.endSymbols.hasOwnProperty(symbol)) {
                    return res;
                }
                lexerBeforeSymbol.restore(lexer);
            } while (lexer.type !== lexer.END);
            return res;
        },

        constError: function (variable) {
            return "(function () {throw new Error('TypeError: " + variable + " is read-only');})()";
        }
    };

    var getExpression = pkg.internals.getExpression;


    pkg.internals.getConstraintString = function (context) {
        var lexer = context.lexer,
            begin = lexer.save(),
            tmp = lexer.getWhite(true),
            typeConstraint;

            lexer.nextSymbol();

        if (lexer.type & (lexer.VARIABLE | lexer.STRING)) {
            if (lexer.type === lexer.STRING) {
                try {
                    typeConstraint = JSON.parse(lexer.symbol);
                    if (typeConstraint === "float" || typeConstraint === "double") {
                        typeConstraint = "'number'";
                    }
                } catch (e) {
                    lexer.restore(begin);
                    return "";
                }
            } else {
                var lowerType = lexer.symbol.toLowerCase();

                switch(lowerType) {
                case "integer":
                case "int":
                    typeConstraint = "'int'";
                    break;
                case "number":
                    typeConstraint = "'number'";
                    break;
                case "list":
                case "array":
                    typeConstraint = "Array";
                    break;
                case "automaton":
                    typeConstraint = "Automaton";
                    break;
                case "set":
                    typeConstraint = "Set";
                    break;
                case "bool":
                    typeConstraint = "'boolean'";
                    break;
                case "boolean":
                case "string":
                case "object":
                case "undefined":
                case "function":
                    typeConstraint = "'" + lowerType + "'";
                    break;
                case "state":
                    typeConstraint = "null"; // FIXME: no constraint for states
                }
            }
            return tmp + typeConstraint;
        }

        lexer.restore(begin);
        return "";
    };

    function addOperatorParenthesis(o, opts) {
        o.afterLeft = (
            o.afterLeft
                ? o.afterLeft + opts.afterLeft
                : opts.afterLeft
        );

        o.transformedOperator = true;

        var left = o;
        while (
            left.prev
         && (!opts.weakerThan || opts.weakerThan.indexOf(left.prev.op) === -1
        )) {
            left = left.prev;
        }

        if (left.prev) {
            left.prev.beforeRight = (
                left.prev.beforeRight
                    ? opts.beforeLeft + left.prev.beforeRight
                    : opts.beforeRight
            );
        } else {
            left.beforeLeft = (
                left.beforeLeft
                    ? opts.beforeLeft + left.beforeLeft
                    : opts.beforeLeft
            );
        }

        var right = o;
        while (
            (right.right && right.right.hasOwnProperty("op"))
         && (
               (
                    !opts.weakerThan
                 || opts.weakerThan.indexOf(right.right.op) === -1
            ) && (
                    !opts.sameLevel
                 || opts.sameLevel.indexOf(right.right.op) === -1))
        ) {
            right = right.right;
        }

        if (right.right && right.right.hasOwnProperty("op")) {
            right.right.afterLeft  = (
                right.right.afterLeft
                    ? right.right.afterLeft + opts.afterRight
                    : opts.afterRight
            );
        } else {
            right.afterRight = (
                right.afterRight
                    ? right.afterRight + opts.afterRight
                    : opts.afterRight
            );
        }
    }

    function operatorChainToString(o) {
        if (typeof o === "string") {
            return o;
        }

        if (o.op === "?") {
            // this works because " ? : " is the most predecedent operator
            return (
                (o.beforeLeft || "") + o.left + (o.afterLeft || "")
              + o.white
              + "?"     + o.ifTrueExpression
              + o.colon + o.ifFalseExpression
              + (o.afterRight || "")
            );
        }

        var rightTrim = operatorChainToString(o.right);
        var rightSpaces = "";

        while (rightTrim.length && !rightTrim.slice(-1).trim()) {
            rightSpaces = rightTrim.slice(-1) + rightSpaces;
            rightTrim   = rightTrim.substr(0, rightTrim.length - 1);
        }

        if (o.transformedOperator) {
            return (
                (o.beforeLeft || "")  + o.left    + o.afterLeft
              + (o.beforeRight || "") + rightTrim + (o.afterRight || "")
              + rightSpaces
			);
            //TODO: check correctness
        }

        return (
              (o.beforeLeft || "")  + o.left    + (o.afterLeft || "")
            + (o.white || "")       + o.op
            + (o.beforeRight || "") + rightTrim + (o.afterRight || "")
            + rightSpaces
        );
    }

    function handleOperators(o) {
        /**
         * priorities:
         *  - +, -, =, *
         *  - union, inter, cross
         *  - minus
         *  - contains, belongs_to, hasKey, subset_of, symdiff
         *  - <, <=, >= ,>, ==, ===
         *  - ||
         *  - &&
         *  - ? :
         */
        if (o.right && o.right.hasOwnProperty("op")) {
            o.right.prev = o;
        }

        switch (o.op) {
        case "==":
            addOperatorParenthesis(o, {
                beforeLeft: (o.white || "") + "audescript.eq(",
                afterLeft:  ",",
                afterRight: ")",
                weakerThan: [
                    "||", "&&",
                    "?"
                ],
                sameLevel:  [
                    "<", ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!=="
                ]
            });
            break;
        case "!=":
            addOperatorParenthesis(o, {
                beforeLeft: (o.white || "") + "!audescript.eq(",
                afterLeft:  ",",
                afterRight: ")",
                weakerThan: [
                    "||", "&&",
                    "?"
                ],
                sameLevel:  [
                    "<", ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!=="
                ]
            });
            break;
        case "?":
            if (o.ifTrueExpression.hasOwnProperty("op")) {
                o.ifTrueExpression = operatorChainToString(handleOperators(o.ifTrueExpression));
            }
            if (o.ifFalseExpression.hasOwnProperty("op")) {
                o.ifFalseExpression = operatorChainToString(handleOperators(o.ifFalseExpression));
            }
            return o; // "? : " operator is a specific case
//             return o.left + o.white + "?" + o.ifTrueExpression + o.colon + o.ifFalseExpression;
        case "contains":
        case "subsetof":
        case "sym_diff":
        case "belongs_to":
            addOperatorParenthesis(o, {
                beforeLeft: " " + o.not + o.op  + "(",
                afterLeft:  "," + (o.white === " " ? "" : o.white),
                afterRight: ")",
                weakerThan: [
                    "<",  ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!==",
                    "||", "&&",
                    "?"
                ],
                sameLevel:  [
                    "contains",
                    "belongs_to",
                    "has_key",
                    "subset_of",
                    "symdiff"
                ]
            });
            break;
        case "has_key":
            addOperatorParenthesis(o, {
                beforeLeft: " " + o.not + "(",
                afterLeft:  ").hasKey(" + (o.white === " " ? "" : o.white),
                afterRight: ")",
                weakerThan: [
                    "<", ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!==",
                    "||", "&&",
                    "?"
                ],
                sameLevel: [
                    "contains",
                    "belongs_to",
                    "has_key",
                    "subset_of",
                    "symdiff"
                ]
            });
            break;
        default:
            var sameLevel, weakerThan;
            if (o.op === "union" || o.op === "inter" || o.op === "cross") {
                sameLevel  = [
                    "union",
                    "inter",
                    "cross"
                ];
                weakerThan = [
                    "minus",
                    "contains",
                    "belongs_to",
                    "has_key",
                    "subset_of",
                    "symdiff",
                    "<", ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!==",
                    "||", "&&",
                    "?"
                ];
            } else if (o.op === "minus") {
                weakerThan = [
                    "contains",
                    "belongs_to",
                    "has_key",
                    "subset_of",
                    "symdiff",
                    "<", ">",
                    "<=", ">=",
                    "==", "===",
                    "!=", "!==",
                    "||", "&&",
                    "?"
                ];
                sameLevel  = [
                    "minus"
                ];
            }

            if (o.alphaOp) {
                // inter, union, cross, minus
                addOperatorParenthesis(o, {
                    beforeLeft: (o.white || "") + o.not + o.op + "(",
                    afterLeft:  ",",
                    afterRight: ")",
                    weakerThan: weakerThan,
                    sameLevel:  sameLevel
                });
            }
        }

        if (o.right && o.right.hasOwnProperty("op")) {
            handleOperators(o.right);
        }

        return o;
    }

    pkg.internals.handleOperator = function (context, exprs) {
        if (context.acceptOperator) {
            return exprs;
        }

        return operatorChainToString(handleOperators(exprs));
    };
    pkg.jsFeatures = {
        letDeclaration:      false,
        arrowFunction:       false,
        letExpression:       false,
        iterations:          false,
        constDeclaration:    false,
        abbreviatedFunction: false,
        destructuring:       false
    };


    try {
        pkg.jsFeatures.arrowFunction = eval("(x => true)()");
    } catch (ignore) {}

    if (typeof that.Packages !== "object" || String(that.Packages) !== "[JavaPackage ]") {
        // disable this feature detection in rhino as it crashes it
        try {
            pkg.jsFeatures.abbreviatedFunction = eval("(function () true)()");
        } catch (ignore) {}
    }

    try {
        pkg.jsFeatures.letExpression    = eval("(function () {var a=1, t; let (a=2) {if (a === 2) {t = true}}; return t && a === 1;})();");
    } catch (ignore) {}

    try {
        pkg.jsFeatures.letDeclaration   = eval("(function () {var a=1, t; if (true) {let a = 2;t = a === 2} return t && a === 1;})();");
    } catch (ignore) {}

    try {
        pkg.jsFeatures.constDeclaration = eval("(function () {const a=1; try{a=2;} catch (e) {return true;} return false;})();");
    } catch (ex) {
        if (ex instanceof TypeError) {
            pkg.jsFeatures.constDeclaration = true;
        }
    }

    try {
        pkg.jsFeatures.iterations       = eval("(function () {for (let i of [1,2]) {} return true;})()");
    } catch (ignore) {}

    try {
        pkg.jsFeatures.destructuring    = eval("(function () {var [a,b,c] = [1,2,3]; return a === 1 && b === 2 && c === 3})()");
    } catch (ignore) {}

    var parseStatementAfter;

    function tryComma(context, white, begin, res) {
        if (context.lexer.symbol === ",") {
            if (!context.commaAllowed) {
                context.lexer.restore(begin);
                return res + white;
            }

            context.gotComma = true;
            return res + white + "," + getExpression(context, {
                value: context.value,
                commaAllowed: true,
                endSymbols: context.endSymbols,
                constraintedVariables: context.constraintedVariables
            });
        }
        return false;
    }

    function trySemicolon(context, white, begin, res) {
        if (context.lexer.symbol === ";") {
            if (context.value) {
                context.lexer.restore(begin);
                return res + white;
            }
            return res + white + context.lexer.symbol + context.lexer.getWhite();
        }
        return false;
    }

    function tryColon(context, white, begin, varName) {
        var lexer = context.lexer;
        if (lexer.symbol === ":") {
            if (context.value) {
                lexer.restore(begin);
                return varName + white; // syntax error
            }


            var tmp, white2, matches, constraint, typeOfVar, defaultValue;

            matches = /([\s]*)[\S]+/g.exec(varName);
            varName = varName.trim();

            if (matches && lexer.isIdentifier(varName)) {
                // variable declaration
                defaultValue = "";
                lexer.nextSymbol();

                if (lexer.type === lexer.WHITESPACE) {
                    if (lexer.symbol.match("\n")) {
                        lexer.restore(begin);
                        return false;
                    }
                    tmp += lexer.symbol;
                    lexer.nextSymbol();
                }

                context.constraintedVariables.type.add(varName);
                tmp = matches[1] + (
                    context.jsFeatures.letDeclaration
                        ? "let "
                        : "var "
                ) + varName + white + "=";

                var restore;

                if (lexer.type === lexer.VARIABLE) {
                    typeOfVar = lexer.symbol;
                    white  = lexer.getWhite(true);
                    var beforeSymbol = lexer.save();
                    lexer.nextSymbol();

                    if (lexer.symbol === "=") {
                        defaultValue = getExpression(context, {
                            value: true,
                            constraintedVariables: context.constraintedVariables
                        });
                    } else {
                        lexer.restore(beforeSymbol);
                    }

                    switch (typeOfVar.toLowerCase()) {
                    case "integer":
                    case "int":
                        tmp += (
                            defaultValue
                                ? ("audescript.as(0," + defaultValue + ", true)")
                                : "0"
                        );
                        context.constraintedVariables.type.add("0" + varName);
                        break;
                    case "list":
                    case "array":
                    case "table":
                        tmp += (
                            defaultValue
                                ? ("audescript.as([]," + defaultValue + ")")
                                : "[]"
                        );
                        break;
                    case "state":
                        context.constraintedVariables.type.remove(varName);
                        tmp += defaultValue || "''";
                        break;
                    case "string":
                        tmp += (
                            defaultValue
                                ? ("audescript.as(''," + defaultValue + ")")
                                : "''"
                        );
                        break;
                    case "bool":
                    case "boolean":
                        tmp += (
                            defaultValue
                                ? ("audescript.as(false," + defaultValue + ")")
                                : "false"
                        );
                        break;
                    case "automaton":
                        tmp += (
                            defaultValue
                                ? "audescript.as(new Automaton," + defaultValue + ")"
                                : "new Automaton"
                        );
                        break;
                    case "function":
                        tmp += (
                            defaultValue
                                ? "audescript.as(function () {}," + defaultValue + ")"
                                : "function () {}"
                        );
                        break;
                    case "mappingfunction":
                        tmp += defaultValue || "getMappingFunction()";
                        break;
                    case "set":
                        if (defaultValue) {
                            tmp += (
                                (defaultValue.trim().substr(0, 7) === "to_set(")
                                    ? defaultValue
                                    : "to_set(" +  defaultValue + ")"
                            );
                        } else {
                            tmp   += "new Set()";
                            white2 = lexer.getWhite(true);
                            restore = lexer.save();
                            lexer.nextSymbol();
                            if (lexer.symbol === "of") {
                                constraint = pkg.internals.getConstraintString(context);

                                if (constraint) {
                                    tmp += ";" + white2 + varName + ".setTypeConstraint(" + constraint + ")";
                                } else {
                                    lexer.restore(begin);
                                    return varName + white;
                                }

                                tmp += lexer.getWhite(true);
                                restore = lexer.save();
                                lexer.nextSymbol();

                                if (lexer.symbol === "=") {
                                    tmp += ";" + varName + ".unionInPlace(" + getExpression(context, {
                                        value: true,
                                        constraintedVariables: context.constraintedVariables
                                    }) + ")";
                                } else {
                                    lexer.restore(restore);
                                }
                            } else {
                                white += white2;
                                lexer.restore(restore);
                            }
                        }
                        break;
                    default:
                        tmp += "new " + typeOfVar;
                    }

                    tmp += white;
                } else {
                    lexer.restore(begin);
                    return false;
                }

                white = lexer.getWhite();
                restore = lexer.save();
                lexer.nextSymbol();

                // we don't include res here as it is in tmp
                if (lexer.symbol === ";") {
                    return tmp + white + lexer.symbol;
                }

                lexer.restore(restore);
                return tmp + white;
            }

            lexer.restore(begin);

            return varName + white;
        }
        return false;
    }

    function tryDotAfter(context, white, begin, res) {
        var lexer = context.lexer;
        if (lexer.symbol === ".") {
            return parseStatementAfter(
                context,
                res + white + "." + lexer.getWhite() + lexer.nextSymbol(context)
            );
        }
        return false;
    }

    function tryInterro(context, white, begin, res) {
        var lexer = context.lexer;
        if (lexer.symbol === "?") {
            if (context.onlyOneValue) {
                lexer.restore(begin);
                return res + white;
            }

            var o = {
                value: true,
                constraintedVariables: context.constraintedVariables
            };

            return pkg.internals.handleOperator(context, {
                op: "?",
                left: pkg.utils.autoTrim(res),
                white: white,
                not: "",
                alphaOp: false,
                ifTrueExpression: getExpression(context, o),
                colon: lexer.getWhite() + lexer.nextSymbol() + lexer.getWhite(),
                ifFalseExpression: getExpression(context, o)
            });
        }
        return false;
    }

    function tryBracketParen(context, white, begin, res) {
        if (context.lexer.symbol === "[") {
            return parseStatementAfter(context,
                res + white + "[" + getExpression(context, {
                    constraintedVariables: context.constraintedVariables,
                    endSymbols: {"]": true}
                }) + context.lexer.nextSymbol()
            ); // symbol should be "]"
        }

        if (context.lexer.symbol === "(") {
            return parseStatementAfter(context,
                res + white + "(" + getExpression(context, {
                    constraintedVariables: context.constraintedVariables,
                    commaAllowed: true,
                    endSymbols: {")": true}
                }) + context.lexer.nextSymbol()
            ); // symbol should be ")"
        }

        return false;
    }

    function tryArrowFunction(context, white, begin, args) {
        var lexer = context.lexer;
        var oldType = begin.lastSignificantType;
        if (lexer.symbol === "=>"  && (oldType & (lexer.VARIABLE | lexer.CLOSEPAREN))) {
            var expr = lexer.getWhite(!context.jsFeatures.arrowFunction) + getExpression(context, {
                constraintedVariables: pkg.utils.copy(context.constraintedVariables)
            });

            if (context.jsFeatures.arrowFunction) {
                return white + args + "=>" + expr;
            }

            return white + "function" +
                    (oldType === lexer.CLOSEPAREN ? args : "(" + args + ")") +
                    (expr.trim()[0] === "{" ? expr : "{return " + expr + "}");
        }
        return false;
    }

    function tryOperation(context, white, begin, res) {
        var lexer = context.lexer,
            type = lexer.type,
            symbol = lexer.symbol;

        if (type === lexer.OPERATOR) {
            if (context.onlyOneValue && symbol !== "!") {
                lexer.restore(begin);
                return res + white;
            }

            if (
                symbol[symbol.length - 1] === "="
             && symbol !== ">="
             && symbol !== "<="
             && symbol !== "==="
             && symbol !== "=="
             && symbol !== "!="
             && symbol !== "!=="
            ) {
                var trimRes, newVal;
                trimRes = res.trim();
                newVal  = getExpression(context, {
                    value: true,
                    constraintedVariables: context.constraintedVariables
                });

                if (
                    (
                        !context.jsFeatures.destructuring
                     && (trimRes[0] === "{" || trimRes[0] === "[")
                    )
                 || trimRes[0] === "("
                ) {
                    return (
                        res + white
                      + pkg.destructToJS(res, newVal, null, context.constraintedVariables)
                      + parseStatementAfter(context)
                    );
                }

                if (context.constraintedVariables.type.contains(trimRes)) {
                    context.immediatlyReturn = true;
                    if (symbol.length > 1) {
                        return (
                            white + res
                          + "=audescript.as("
                              + trimRes
                              + ","
                              + trimRes + symbol.substr(0, symbol.length - 1)
                              + newVal
                              + ","
                              + (
                                  context.constraintedVariables.type.contains("0" + trimRes)
                                      ? "true"
                                      : "false"
                              )
                          + ")" + parseStatementAfter(context)
                        );
                    }

                    return (
                        white + res
                      + "=audescript.as("
                          + trimRes
                          + ","
                          +  newVal
                          + ","
                          + (
                              context.constraintedVariables.type.contains("0" + trimRes)
                                  ? "true"
                                  : "false"
                          )
                      + ")" + parseStatementAfter(context)
                    );
                }

                if (!context.jsFeatures.const && context.constraintedVariables.consts.contains(trimRes)) {
                    context.immediatlyReturn = true;
                    return (
                        white + res.replace(/[\S]+/g, "")
                      + pkg.internals.constError(trimRes)
                      + newVal.replace(/[\S]+/g, "")
                      + parseStatementAfter(context)
                    );
                }

                return res + white + symbol + newVal + parseStatementAfter(context);
            }

            var o = {
                acceptOperator: true,
                value: true,
                noWhite: true,
                constraintedVariables: context.constraintedVariables
            };

            return pkg.internals.handleOperator(context, {
                op: symbol,
                alphaOp: false,
                left: pkg.utils.autoTrim(res),
                white: white,
                not: "",
                beforeRight: lexer.getWhite(),
                right: getExpression(context, o)
            });
        }
        return false;
    }

    // we normalize operators with this table
    var alphaOperatorRenames = {
        "u":          "union",
        "m":          "minus",
        "n":          "inter",
        "x":          "cross",
        "symdiff":    "sym_diff",
        "subsetof":   "subset_of",
        "element_of": "belongs_to",
        "elementof":  "belongs_to",
        "belongsto":  "belongs_to",
        "haskey":     "has_key"
    };

    function tryAlphaOperator(context, white, begin, res) {
        var lexer  = context.lexer,
            symbol = lexer.symbol.toLowerCase();

        var not = "";
        if (symbol && symbol[0] === "!") {
            not = "!";
            symbol = symbol.substr(1);

            if (alphaOperatorRenames.hasOwnProperty(symbol)) {
                symbol = alphaOperatorRenames[symbol];
            }

            if (
                symbol !== "contains"
             && symbol !== "subset_of"
             && symbol !== "belongs_to"
             && symbol !== "has_key"
            ) {
                // only these alpha operators can be negated
                context.lexer.restore(begin);
                return res + white;
            }
        } else if (alphaOperatorRenames.hasOwnProperty(symbol)) {
            symbol = alphaOperatorRenames[symbol];
        }

        if (
            symbol === "inter"
         || symbol === "union"
         || symbol === "cross"
         || symbol === "minus"
         || symbol === "contains"
         || symbol === "subsetof"
         || symbol === "belongs_to"
         || symbol === "has_key"
         || symbol === "sym_diff"
        ) {

            var maybeBeforeEqualSign = lexer.save();
            var white2  = lexer.getWhite(true);
            var symbol2 = lexer.nextSymbol();

            if (lexer.type === lexer.OPERATOR) {
                if (
                    symbol2 !== "="
                 || symbol === "contains"
                 || symbol === "has_key"
                 || symbol === "subset_of"
                 || symbol === "belongs_to"
                 || symbol === "sym_diff"
                 || symbol === ""
                ) {
                    // syntax error (?)
                    lexer.restore(begin);
                    return res + white;
                }

                return (
                    res + "." + symbol + "InPlace("
                  + (white === " " ? "" : white) + white2
                  + getExpression(context, {
                        value: true,
                        constraintedVariables: context.constraintedVariables
                    })
                  + ")"
                );
            }

            // white2 is not relevant anymore
            lexer.restore(maybeBeforeEqualSign);

            var o = {
                value: true,
                noWhite: true,
                acceptOperator: true,
                constraintedVariables: context.constraintedVariables
            };

            return pkg.internals.handleOperator(context, {
                op: symbol,
                left: pkg.utils.autoTrim(res),
                white: white,
                not: not,
                beforeRight: lexer.getWhite(),
                right: getExpression(context, o),
                alphaOp: true
            });
        }
        return false;
    }

    function tryFail(context, white, begin, res) {
        context.lexer.restore(begin);
        return res + white;
    }

    function tryEndAfter(context, white, begin, res) {
        if (context.lexer.type === context.lexer.END || (context.endSymbols && context.endSymbols.hasOwnProperty(context.lexer.symbol))) {
            context.lexer.restore(begin);
            return res + white;
        }
        return false;
    }

    parseStatementAfter = function (context, res) {
        if (typeof res !== "string") {
            res = "";
        }

         if (res.trim() && context.onlyOneValue) {
             return res;
         }

        var lexer   = context.lexer,
            white   = lexer.getWhite(),
            begin   = lexer.save();

        lexer.nextSymbol();

        return (
            tryEndAfter(context, white, begin, res)      ||
            tryComma(context, white, begin, res)         ||
            trySemicolon(context, white, begin, res)     ||
            tryColon(context, white, begin, res)         ||
            tryDotAfter(context, white, begin, res)      ||
            tryInterro(context, white, begin, res)       ||
            tryArrowFunction(context, white, begin, res) ||
            tryBracketParen(context, white, begin, res)  ||
            tryOperation(context, white, begin, res)     ||
            tryAlphaOperator(context, white, begin, res) ||
            tryFail(context, white, begin, res)
        );
    };

    pkg.internals.parseStatementAfter = parseStatementAfter;

    var _ = pkg.l10n || (that.libD && that.libD.l10n ? that.libD.l10n() : function (s) { return s; });

    function notdef() {}

    var Tuple      = that.Tuple      || notdef;
    var Automaton  = that.Automaton  || notdef;
    var Transition = that.Transition || notdef;

    pkg.StopIteration = {};
    pkg.ReturnValue = function (v) {
        this.v = v;
    };

    pkg.ThrowValue = function (v) {
        this.v = v;
    };

    function tuplesEq(t1, t2) {
        if (t1.length !== t2.length) {
            return false;
        }

        var j;
        for (j = 0; j < t1.length; ++j) {
            if (!pkg.eq(t1[j], t2[j])) {
                return false;
            }
        }

        return true;
    }

    // checks "real" equality between v1 and v2
    pkg.eq = function (v1, v2) {
        if (v1 instanceof Tuple && v1.length === 1) {
            return pkg.eq(v2, v1[0]);
        }

        /*eslint-disable eqeqeq */

        return v1 == v2 || (
            typeof v1 === typeof v2
            && (v1 instanceof Set && v2 instanceof Set
                ? v1.card() === v2.card() && !v1.minus(v2).card()
                : (v1 instanceof Transition && v2 instanceof Transition
                    ?          pkg.eq(v1.symbol, v2.symbol)
                            && pkg.eq(v1.startState, v2.startState)
                            && pkg.eq(v1.endState, v2.endState)
                    : (v1 instanceof Automaton && v2 instanceof Automaton
                        ?          pkg.eq(v1.states, v2.states)
                                && pkg.eq(v1.finalStates, v2.finalStates)
                                && pkg.eq(v1.trans, v2.trans)
                                && pkg.eq(v1.q_init, v2.q_init)
                        : (v1 instanceof Tuple && v2 instanceof Tuple)
                            ? tuplesEq(v1, v2)
                            : JSON.stringify(v1) === JSON.stringify(v2)
                            )
                        )
                    )
        );

        /*eslint-enable eqeqeq */
    };

    // checks if value can be assigned to variable and return the right value. integerCheck enforce value being an integer.
    pkg.as = function (variable, value, integerCheck) {
        if (variable instanceof Set && value instanceof Set) {
            if (!variable.typeConstraint  || variable.typeConstraint === value.constraintType) {
                return value;
            }

            var newVal = new Set();
            newVal.setTypeConstraint(variable.typeConstraint);
            newVal.unionInPlace(value);
            return value;
        }

        if (value !== null && value !== undefined && variable !== null && value !== undefined) {
            if (typeof value !== typeof variable && value.constructor !== variable.constructor) {
                throw new Error(_("Type Error: types don't match."));
            }
            return integerCheck ? (value > 0 ? Math.floor(value) : Math.ceil(value)) : value;
        }

        if (value !== variable) {
            throw new Error(_("Type Error: types don't match."));
        }

        return value;
    };

    pkg.ct = function (val, type) {
        if (typeof type === "string") {
            if (type === "int") {
                if (!(typeof val === "number" && val % 1 === 0)) {
                    throw new TypeError(_("type mismatch."));
                }
            } else if (typeof val !== type) {
                throw new TypeError(_("type mismatch."));
            }
        } else if (val !== null && !(val instanceof type)) {
            throw new TypeError(_("type mismatch."));
        }
        return val;
    };

    Object.defineProperty(Object.prototype, "forEach", {
        enumerable: false,
        writable:   true,
        value: function (callback) {
            var i;
            for (i in this) {
                if (this.hasOwnProperty(i)) {
                    callback(this[i]);
                }
            }
        }
    });

    try { // eval to allow parsing of the file even in browsers not supporting yield.
        eval(
            "Object.defineProperty(Object.prototype, 'iterator', {"
                +     "enumerable:false,"
                +     "writable: true,"
                +     "configurable: true,"
                +     "value: function () {"
                +         "for (var i in this) {"
                +             "if (this.hasOwnProperty(i)) {"
                +                 "yield this[i];"
                +             "}"
                +         "}"
                +         "return;"
                +     "}"
                + "});"
        );
    } catch (ignore) {}
    function destructNext(s, i, end, dontCheck) {
        while (!s[i].trim()) {
            ++i;
        }

        if (!dontCheck) {
            if (s[i] === ",") {
                return i + 1;
            }

            if (s[i] !== "," && s[i] !== end) {
                throw new Error("Malformed destructing string: " + s);
            }
        }
        return i;
    }

    function destructArray(e, destructStr, res, i, end) {
        ++i;
        var k = 0;
        while (destructStr[i] !== end) {
            i = destructNext(destructStr, i, "", true);
            if (destructStr[i] !== ",") {
                i = pkg.destruct((e || [])[k], destructStr, res, true, i);
            }
            i = destructNext(destructStr, i, end);
            ++k;
        }
        if (destructStr[i] !== end) {
            throw new Error("Malformed destructing string: " + destructStr);
        }
        return i + 1;
    }

    function destructObject(e, destructStr, res, i) {
        ++i;
        var key, endObject, start;
        while (destructStr[i] !== "}") {
            i = destructNext(destructStr, i, "", true);

            if (destructStr[i] === "\"" || destructStr[i] === "'") {
                endObject = destructStr[i];
                start = i++;
                while (destructStr[i] && destructStr[i] !== endObject) {
                    if (destructStr[i] === "\\") {
                        ++i;
                    }
                    ++i;
                }
                if (!destructStr[i]) {
                    throw new Error("Malformed destructing string: " + destructStr);
                }
                key = eval(destructStr.substring(start, ++i));
            } else {
                start = i;
                while (destructStr[i] !== ":" && destructStr[i].trim()) {
                    ++i;
                }
                key = destructStr.substring(start, i);
            }

            i = destructNext(destructStr, i, "", true);
            if (destructStr[i] !== ":") {
                throw new Error("Malformed destructing string: " + destructStr);
            }
            ++i;
            i = destructNext(destructStr, i, "", true);
            i = pkg.destruct((e || {})[key], destructStr, res, true, i);
            i = destructNext(destructStr, i, "}");
        }
        if (destructStr[i] !== "}") {
            throw new Error("Malformed destructing string: " + destructStr);
        }
        return i + 1;
    }

    pkg.destructToJS = function (vars, newVal, listOfVals, constraintedVariables) {
        if (!listOfVals) {
            listOfVals = [];
            pkg.destruct(null, vars, listOfVals);
        }

        var resToString = "'" + vars.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\\n") + "'";
        var ret = "(function () {audescript.des=audescript.destruct(" + newVal + "," + resToString + ");";
        var index, lovLen;

        for (index = 0, lovLen = listOfVals.length; index < lovLen; ++index) {
            if (listOfVals.hasOwnProperty(index)) {
                if (constraintedVariables.consts.contains(listOfVals[index])) {
                    ret += pkg.internals.constError(listOfVals[index]) + ";";
                } else if (constraintedVariables.type.contains(listOfVals[index])) {
                    ret += listOfVals[index] + "=audescript.as(" + listOfVals[index] + ", audescript.des." + listOfVals[index] + ");";
                } else {
                    ret += listOfVals[index] + "=audescript.des." + listOfVals[index] + ";";
                }
            }
        }
        return ret + "audescript.des=null;})()";
    };

    pkg.destruct = function (e, destructStr, res, returnCurrentIndex, i) {
        if (!res) {
            res = {};
        }

        i = destructNext(destructStr, i || 0, "", true);

        if (destructStr[i] === "[" || destructStr[i] === "(") {
            i = destructArray(e, destructStr, res, i, destructStr[i] === "[" ? "]" : ")");
        } else if (destructStr[i] === "{") {
            i = destructObject(e, destructStr, res, i);
        } else {
            var j = i++;
            while (destructStr[i] && ",]})".indexOf(destructStr[i]) === -1) {
                ++i;
            }

            if (res instanceof Array) {
                res.push(destructStr.substring(j, i));
            } else {
                res[destructStr.substring(j, i)] = e;
            }
        }

        if (returnCurrentIndex) {
            return i;
        }

        return res;
    };


    pkg.internals.foreachReplacements = function (context) {
        var lexer = context.lexer;
        if (lexer.symbol === "break") {
            return "throw audescript.StopIteration";
        }

        if (lexer.symbol === "return" || lexer.symbol === "throw") {
            var state = lexer.save();
            var symb = lexer.nextSymbol();

            if (lexer.type === lexer.WHITESPACE) {
                if (symb.indexOf("\n") !== -1) {
                    lexer.restore(state);

                    if (lexer.symbol === "throw") {
                        return "throw"; // Syntax error
                    }

                    return "throw new audescript.ReturnValue(undefined)";
                }
                symb = lexer.nextSymbol();
            }

            lexer.restore(state);

            if (symb === ";") {
                if (lexer.symbol === "throw") {
                    return "throw"; // Syntax error
                }
                return "throw new audescript.ReturnValue(undefined)";
            }

            if (lexer.symbol === "throw") {
                return "throw new audescript.ThrowValue(" + getExpression(context, {
                    value: true,
                    constraintedVariables: context.constraintedVariables
                }) + ")";
            }

            return "throw new audescript.ReturnValue(" + getExpression(context, {
                value: true,
                constraintedVariables: context.constraintedVariables
            }) + ")";
        }

        if (lexer.symbol === "continue") {
            return "return";
        }

        return lexer.symbol;
    };

    function comprehensiveSet(context, declarationSymbol, begin, white, expr1) {
        var lexer = context.lexer;
        if (lexer.lookAhead() === "{") {
            lexer.nextChar();
            var n1 = white + getExpression(context, {
                value: true,
                endSymbols: {"," : true},
                constraintedVariables: context.constraintedVariables
            });

            lexer.nextSymbol();

            if (lexer.symbol !== ",") {
                lexer.restore(begin);
                return "";
            }

            white += lexer.getWhite();

            if (lexer.substring(lexer.curPos(), lexer.curPos() + 3) !== "...") {
                lexer.restore(begin);
                return "";
            }

            lexer.nextChar(2);

            white += lexer.getWhite();

            lexer.nextSymbol();

            if (lexer.symbol !== ",") {
                lexer.restore(begin);
                return "";
            }

            var n2 = getExpression(context, {
                constraintedVariables: context.constraintedVariables
            });

            if (lexer.nextSymbol() !== "}") {
                lexer.restore(begin);
                return "";
            }

            white += lexer.getWhite();
            lexer.nextSymbol();

            if (lexer.symbol !== ")") {
                lexer.restore(begin);
                return "";
            }

            var bf = "", ef = "", foreachBody = getExpression(context, {
                noValue: true,
                constraintedVariables: copy(context.constraintedVariables)
            });

            if (foreachBody.trim()[0] !== "{") {
                bf = "{";
                ef = "}";
            }

            declarationSymbol =
                declarationSymbol || (
                        /^[\s]*(let|var)/g.exec(expr1)
                     || ["", (context.jsFeatures.letDeclaration ? "let" : "var")]
                )[1];

            expr1 = expr1.replace(/^([\s]*)(?:let|var) */g, "$1");

            return (
                "for (" + declarationSymbol + (
                    declarationSymbol[declarationSymbol.length - 1].trim()
                        ? " "
                        : ""
                    )
                + expr1
                + (
                    expr1[expr1.length - 1].trim() ? " " : ""
                ) + "=" + n1 + "; "
                + expr1.trim() + " <= " + n2 + ";"
                + white + "++" + expr1.trim()
                + ")" + bf + foreachBody + ef
            );
        }

        return "";
    }

    pkg.internals.parseForeach = function (context) {
        var lexer   = context.lexer,
            begin   = lexer.save(),
            keyword = lexer.symbol,
            beforeParenthesis = lexer.getWhite();

        lexer.nextSymbol();

        if (lexer.symbol !== "(") {
            lexer.restore(begin);
            return keyword;
        }

        var expr1  = getExpression(context, {
            constraintedVariables: context.constraintedVariables
        });

        var inExpr = lexer.nextSymbol(), declarationSymbol = "";

        if (context.jsFeatures.iterations) {
            if (keyword === "foreach" && !expr1.match(/^[\s]*(?:let|var) ?/)) {
                expr1 = (
                    context.jsFeatures.letDeclaration
                        ? "let "
                        : "var "
                ) + pkg.utils.autoTrim(expr1);
            }
        } else {
            var key = /^[\s]*(let|var) */g.exec(expr1);

            if (key || keyword === "foreach") {
                declarationSymbol = (
                    key
                        ? key[1] + " "
                        : (
                            context.jsFeatures.letDeclaration
                                ? "let "
                                : "var "
                        )
                );
            }

            expr1 = expr1.replace(/^[\s]*(?:let|var) */g, "");
        }

        if (lexer.type === lexer.WHITESPACE) {
            expr1 += inExpr;
            inExpr = lexer.nextSymbol();
        }

        if (
            (inExpr !== "in" && inExpr !==  "of")
         || (inExpr === "in" && keyword === "for")
        ) {
            lexer.restore(begin);
            return keyword;
        }

        var c = comprehensiveSet(
            context,
            declarationSymbol,
            lexer.save(),
            lexer.getWhite(),
            expr1
        );

        if (c) {
            return c;
        }

        var expr2  = getExpression(context, {
            constraintedVariables: context.constraintedVariables
        });

        if (lexer.nextSymbol() !== ")") {
            lexer.restore(begin);
            return "for";
        }

        var foreachBody = getExpression(context, {
            inForeach: !context.jsFeatures.iterations,
            noValue: true,
            constraintedVariables: copy(context.constraintedVariables)
        });

        if (context.jsFeatures.iterations) {
            return (
                "for" + beforeParenthesis + "("
              + declarationSymbol + expr1
              + " of "
              + expr2
              + ")" + foreachBody
            );
        }

        var  bf = "", ef = "";
        if (foreachBody.trim()[0] === "{") {
            if (!declarationSymbol && keyword !== "foreach") {
                foreachBody = foreachBody.replace(
                    /([\s]*)\{/,
                    "$1{" + expr1.replace(/\$/g, "$$$$") + "=arguments[0];"
                );
            }
        } else {
            if (!declarationSymbol && keyword !== "foreach") {
                bf = "{" + expr1 + "=arguments[0];";
            } else {
                bf = "{";
            }
            ef = "}";
        }

        return (
            "try{(" + expr2 + ").forEach" + beforeParenthesis
            + "(function ("
            + ((declarationSymbol || keyword === "foreach") ? expr1 : "")
            + ")" + bf
            + foreachBody
            + ef + ")}catch (e) {if (e instanceof audescript.ThrowValue) {throw "
            + (context.inForeach ? "e" : "e.v")
            + ";}else if (e instanceof audescript.ReturnValue) {"
            + (context.inForeach ? "throw e" : "return e.v") + ";}}"
        );
    };


    function tryEnd(context, begin) {
        // stop condition
        if (
            (context.lexer.type === context.lexer.END)
         || (context.endSymbols && context.endSymbols.hasOwnProperty(context.lexer.symbol))
         || ")]}".indexOf(context.lexer.symbol) !== -1
        ) {
            /* case : we are at the end of an expression */
            context.lexer.restore(begin);
            return -1;
        }
        return false;
    }

    function tryBrace(context) {
        var lexer = context.lexer;
        if (lexer.symbol === "{") {
            var begin  = lexer.save();
            var obj = false, oneVal = true;
            var pres = "";

            if (!context.noSetOrObj) {
                do {
                    if (pres) {
                        pres += ",";
                        oneVal = false;
                    }

                    pres += getExpression(context, {
                        value: true,
                        constraintedVariables: context.constraintedVariables
                    }) + lexer.getWhite();
                    lexer.nextSymbol();

                    if (lexer.symbol === ":") {
                        obj = true;
                        pres += lexer.symbol + getExpression(context, {
                            value: true,
                            commaAllowed: false,
                            constraintedVariables: context.constraintedVariables
                        }) + lexer.getWhite();
                        lexer.nextSymbol();
                    }
                } while (lexer.symbol === ",");
            }

            if (!context.noSetOrObj
             && lexer.symbol === "}"
             && !lexer.substring(
                    begin.curPos() - 1,
                    lexer.curPos()
                ).match(/^\{[\s]*\}$/)
            ) {
                return (
                    (obj || (context.noValue && oneVal))
                        ? "{" + pres + "}"
                        : parseStatementAfter(context, "to_set([" + pres + "])")
                );
            }

            lexer.restore(begin);
            return parseStatementAfter(context, "{" + pkg.internals.parseStatements({
                constraintedVariables: copy(context.constraintedVariables),
                endSymbols: { "}": true },
                lexer: context.lexer,
                inForeach: context.inForeach,
                includes: context.includes,
                jsFeatures: context.jsFeatures,
                enforceReturnType: context.enforceReturnType
            }) + lexer.nextSymbol() /* "}" */);
        }
        return false;
    }

    function tryArrayLitteral(context) {
        if (context.lexer.symbol === "[") {
            return parseStatementAfter(context, "[" + getExpression(context, {
                commaAllowed: true,
                constraintedVariables: context.constraintedVariables,
                endSymbols: {
                    "]": true
                }
            }) + context.lexer.nextSymbol() /* "]" */);
        }
        return false;
    }

    function tryParenthesis(context) {
        var lexer = context.lexer;
        if (lexer.symbol === "(") {
            var begin = lexer.save();
            if (context.inForParenthesis) {
                var iter = "", comp = "";

                var decl = getExpression(context, {
                    inForeach: false,
                    constraintedVariables: context.constraintedVariables
                }) + lexer.getWhite();

                if (decl) {
                    comp = getExpression(context, {
                        inForeach: false,
                        constraintedVariables: context.constraintedVariables
                    }) + lexer.getWhite();

                    if (comp) {
                        // we allow the comma operator here in this
                        // specific context (iteration part of the for loop)
                        iter = getExpression(context, {
                            inForeach: false,
                            commaAllowed: true,
                            constraintedVariables: context.constraintedVariables
                        }) + lexer.getWhite();
                    }
                }

                if (lexer.nextSymbol() === ")") {
                    return parseStatementAfter(context,  "(" + decl + comp + iter + ")");
                }
                lexer.restore(begin);
                return false;
            }

            var o = {
                commaAllowed: true,
                constraintedVariables: context.constraintedVariables,
                value: true,
                endSymbols: {")": true}
            };

            var res = "(" + getExpression(context, o) + lexer.nextSymbol(); // ")"
            if (o.gotComma && !context.noTuple) {
                res = " Tuple" + res;
            }
            return parseStatementAfter(context, res);
        }
        return false;
    }

    function tryNewDeleteTypeof(context) {
        var lexer = context.lexer;
        if (
            lexer.symbol === "new"
         || lexer.symbol === "typeof"
         || (!context.value && lexer.symbol === "delete")
        ) {
            return parseStatementAfter(context, lexer.symbol + getExpression(context, {
                onlyOneValue: true,
                commaAllowed: context.commaAllowed,
                constraintedVariables: context.constraintedVariables,
                endSymbols: context.endSymbols
            }));
        }
        return false;
    }

    function tryEmptySet(context) {
        var lexer = context.lexer;

        if (lexer.symbol === "emptySet") {
            var res = lexer.getWhite() + "new Set(";
            var begin = lexer.save();

            if (lexer.nextSymbol() === "(") {
                var constraint = pkg.internals.getConstraintString(context);
                if (lexer.nextSymbol() === ")") {
                    if (constraint) {
                        res += "{typeConstraint:" + constraint + "}";
                    }
                } else {
                    lexer.restore(begin);
                }
            } else {
                lexer.restore(begin);
            }

            return parseStatementAfter(context, res + ")");
        }
        return false;
    }

    function tryPunct(context, begin) {
        var lexer = context.lexer;

        if (lexer.symbol === ";") {
            if (context.value) {
                lexer.restore(begin);
                return -1;
            }
            return lexer.symbol;
        }

        if (lexer.symbol === ",") {
            if (!context.commaAllowed) {
                lexer.restore(begin);
                return -1;
            }

            return "," + getExpression(context, {
                value: context.value,
                commaAllowed: true,
                endSymbols: context.endSymbols,
                constraintedVariables: context.constraintedVariables
            });
        }

        if (lexer.symbol === "!") {
            return "!" + getExpression(context, {
                value: context.value,
                constraintedVariables: context.constraintedVariables,
                onlyOneValue: context.onlyOneValue
            });
        }

        return false;
    }

    function functionBody(context, s, typedArgs) {
        var before = "",
            after  = "";

        if (typedArgs) {
            before = "{";
            after = "}";
            for (var arg in typedArgs) {
                if (typedArgs.hasOwnProperty(arg)) {
                    before += "audescript.ct(" + arg + "," + typedArgs[arg] + ");";
                }
            }
        }

        if (!context.jsFeatures.abbreviatedFunction && s.trim()[0] !== "{") {
            return before + "{return " + s + "}" + after;
        }

        return before + s + after;
    }

    function checkReturn(context, symbol, expr) {
        if (symbol === "return" && context.enforceReturnType) {
            return "audescript.ct(" + expr + "," + context.enforceReturnType + ")";
        }
        return expr;
    }

    function tryInstruction(context, begin) {
        var symbol = context.lexer.symbol;

        if (
            symbol === "return"
         || symbol === "throw"
         || symbol === "break"
         || symbol === "continue"
        ) {
            if (context.value) {
                context.lexer.restore(begin);
                return -1;
            }

            var kw;

            if (context.inForeach) {
                kw = pkg.internals.foreachReplacements(context);
            } else {
                kw = symbol;
            }

            return kw + context.lexer.getWhite() + checkReturn(context, symbol, getExpression(context, {
                constraintedVariables: context.constraintedVariables
            }));
        }

        return false;
    }

    function tryInstructionBlock(context, begin) {
        var lexer  = context.lexer,
            symbol = lexer.symbol,
            state;

        if (symbol === "function") {
            // can also be a value
            state = lexer.save();

            var functionReturnType = null;
            var functionName = lexer.getWhite() + lexer.nextSymbol();

            if (functionName.trim() === "(") {
                functionName = functionName.slice(0, -1);
                lexer.i--;
            }


            if (lexer.nextSymbol() === "(") {
                var parameters = "(";
                var typedArgs = {};
                var argName;
                while (!lexer.end() && lexer.symbol !== ")") {
                    parameters += lexer.getWhite();
                    lexer.nextSymbol();
                    if (lexer.type === lexer.VARIABLE) {
                        argName = lexer.symbol;
                        parameters += lexer.symbol + lexer.getWhite(true);
                        lexer.nextSymbol();
                        if (lexer.symbol === ":") {
                            parameters += lexer.getWhite(true);
                            typedArgs[argName] = pkg.internals.getConstraintString(context);
                        }
                    } else {
                        context.lexer.restore(begin);
                        return -1;
                    }

                    parameters += lexer.getWhite(true);
                    lexer.nextSymbol();
                    if (lexer.symbol === ",") {
                        parameters += "," + lexer.getWhite();
                    } else if (lexer.symbol !== ")") {
                        context.lexer.restore(begin);
                        return -1;
                    }
                }
                parameters += ")" + lexer.getWhite();
                var save = lexer.save();
                lexer.nextSymbol();
                if (lexer.symbol === ":") {
                    parameters += lexer.getWhite(true);
                    functionReturnType = pkg.internals.getConstraintString(context);
                } else {
                    lexer.restore(save);
                }
                return (
                    symbol
                  + functionName
                  + parameters
                  + functionBody(
                        context,
                        getExpression(context, {
                            inForeach: false,
                            constraintedVariables: copy(context.constraintedVariables),
                            enforceReturnType: functionReturnType,
                            endSymbols: {";": true},
                            noSetOrObj: true
                        }),
                        typedArgs
                    )
                );
            } else {
                context.lexer.restore(begin);
                return -1;
            }
        }

        if (
            symbol === "if"
         || symbol === "else"
         || symbol === "do"
         || symbol === "while"
         || symbol === "for"
         || symbol === "switch"
         || symbol === "try"
         || symbol === "catch"
         || symbol === "finally"
        ) {
            if (context.value) {
                lexer.restore(begin);
                return -1;
            }


            if (symbol === "catch") {
                return symbol + getExpression(context, {
                    inForeach: false,
                    noTuple: true,
                    constraintedVariables: context.constraintedVariables
                }) + functionBody(context, getExpression(context, {
                    inForeach: false,
                    constraintedVariables: copy(context.constraintedVariables),
                    noSetOrObj: true
                }));
            }

            if (symbol === "try" || symbol === "finally") {
                return symbol + getExpression(context, {
                    constraintedVariables: copy(context.constraintedVariables),
                    noSetOrObj: true
                });
            }

            var tmp;

            if (
                symbol === "for"
             && !context.jsFeatures.iterations
             && (tmp = pkg.internals.parseForeach(context)) !== "for"
            ) {
                return tmp;
            }

            if (symbol === "do") {
                if (context.value) {
                    lexer.restore(begin);
                    return -1;
                }

                tmp = symbol + getExpression(context, {
                    inForeach: false,
                    constraintedVariables: copy(context.constraintedVariables),
                    noValue: true
                }) + lexer.getWhite();

                var symbol2 = lexer.nextSymbol();
                state = lexer.save();

                if (symbol2 === "while") {
                    return tmp + symbol2 + getExpression(context, {
                        constraintedVariables: copy(context.constraintedVariables)
                    });
                }

                lexer.restore(state);
                return tmp;
            }

            if (symbol === "else") {
                if (context.value) {
                    lexer.restore(begin);
                    return -1;
                }

                return symbol + getExpression(context, {
                    noValue: true,
                    constraintedVariables: copy(context.constraintedVariables)
                });
            }

            return symbol + getExpression(context, {
                inForeach: false,
                inForParenthesis: symbol === "for",
                blockComma: true,
                constraintedVariables: context.constraintedVariables
            }) + getExpression(context, {
                inForeach: (
                    symbol === "while" || symbol === "for" || symbol === "switch"
                )   ? false
                    : context.inForeach,
                constraintedVariables: copy(context.constraintedVariables),
                noValue: true
            });
        }

        return false;
    }

    function tryVariableDeclaration(context, begin) {
        var lexer   = context.lexer,
            keyword = lexer.symbol;

        if (lexer.type !== lexer.INSTRUCTION) {
            return false;
        }

        if (context.value) {
            lexer.restore(begin);
            return -1;
        }

        if (keyword === "const" || keyword === "let" || keyword === "var") {
            var state;
            if (keyword === "let") {
                state = lexer.save();
                lexer.getWhite();
                lexer.nextSymbol();
                lexer.restore(state);
                if (lexer.symbol === "(") {
                    var letVars = getExpression(context, {
                        noTuple: true,
                        onlyOneValue: true,
                        constraintedVariables: context.constraintedVariables
                    }) + lexer.nextSymbol();
                    var state2 = lexer.save();
                    lexer.getWhite();
                    if (lexer.lookAhead() !== "=") {
                        lexer.restore(state2);
                        if (context.jsFeatures.letExpression) {
                            return "let" + letVars + getExpression(context, {
                                constraintedVariables: copy(context.constraintedVariables)
                            });
                        }

                        return (
                            "(function () {var "
                          + letVars.replace(/^([\s]*)\(([\s\S]+)\)([\s]*)$/, "$1$2$3")
                          + ";" + getExpression(context, {
                                constraintedVariables: copy(
                                    context.constraintedVariables
                                )
                            }) + "})()"
                        );
                    }
                }
                lexer.restore(state);
                // regular let, handling just after this.
            }

            var listOfVals,
                semicolonExpected = false,
                vars,
                val,
                addToConsts = keyword === "const" && !context.jsFeatures.constDeclaration;

            var decl = "";

            if (addToConsts || keyword === "let") {
                // Here, const is not supported
                keyword = context.jsFeatures.letDeclaration ? "let" : "var";
            }

            var tmp = "", white = "";

            do {
                vars = lexer.getWhite() + getExpression(context, {
                    onlyOneValue: true,
                    noTuple: true,
                    constraintedVariables: context.constraintedVariables
                }) + lexer.getWhite();

                state = lexer.save();
                lexer.nextSymbol();

                if (lexer.symbol === "=") {
                    val = getExpression(context, {
                        constraintedVariables: context.constraintedVariables,
                        value: true
                    });

                    state = lexer.save();
                    white  = lexer.getWhite();
                    lexer.nextSymbol();
                } else {
                    val = "";
                }

                if (!context.jsFeatures.destructuring || addToConsts) {
                    // destructuring
                    listOfVals = [];
                    pkg.destruct(null, vars, listOfVals);
                }

                if (
                    val && "[{(".indexOf(vars.trim()[0]) !== -1
                 && (
                    !context.jsFeatures.destructuring || "(".indexOf(vars.trim()[0]) !== -1
                 )
                ) {
                    if (decl) {
                        tmp += (semicolonExpected ? ";" : "") + decl + ";";
                        decl = "";
                    }

                    tmp += (
                        keyword + " " + listOfVals.toString() + ";"
                      + pkg.destructToJS(
                          vars,
                          val,
                          listOfVals,
                          context.constraintedVariables
                      ) + white
                    );
                    semicolonExpected = true;
                } else if (decl) {
                    decl += "," + vars + (val ? "=" + val : "") + white;
                } else {
                    decl = (
                        keyword
                     + (vars[0].trim() ? " " : "")
                     + vars + (val ? "=" + val : "") + white
                    );
                }

                if (addToConsts) {
                    for (var i = 0, len = listOfVals.length; i < len; ++i) {
                        if (listOfVals.hasOwnProperty(i)) {
                            context.constraintedVariables.consts.add(listOfVals[i]);
                        }
                    }
                }
            } while (lexer.symbol === ",");

            if (lexer.symbol === ";") {
                return tmp + (semicolonExpected ? ";" : "") + decl + ";";
            }

            lexer.restore(state);
            return tmp + (semicolonExpected ? ";" : "") + decl;
        }

        lexer.restore(begin);
        return -1;
    }

    function tryForeach(context, begin) {
        if (context.lexer.symbol === "foreach") {
            if (context.value) {
                context.lexer.restore(begin);
                return -1;
            }
            return pkg.internals.parseForeach(context);
        }
        return false;
    }

    function tryInclude(context, begin) {
        var lexer = context.lexer;
        if (lexer.symbol === "include") {
            var res = lexer.getWhite(), inc = lexer.nextSymbol();
            if (context.includes) {
                context.includes.push(inc);
            }
            res += lexer.getWhite();
            begin = lexer.save();

            if (lexer.nextSymbol() === ";") {
                return res + lexer.getWhite();
            }

            lexer.restore(begin);
            return res;
        }
        return false;
    }


    function tryOther(context) {
        return parseStatementAfter(context, context.lexer.symbol); // ?? (string, number, litteral, ... ?)
    }


    function parseStatement(context) {
        if (!context.noWhite) {
            context.noWhite = true;
            return context.lexer.getWhite() + parseStatement(context);
        }

        var begin = context.lexer.save();
        context.lexer.nextSymbol();

        var tmpRes =
                tryEnd(context, begin)                 ||
                tryBrace(context)                      ||
                tryArrayLitteral(context)              ||
                tryParenthesis(context)                ||
                tryNewDeleteTypeof(context)            ||
                tryEmptySet(context)                   ||
                tryPunct(context, begin)               ||
                tryForeach(context, begin)             ||
                tryInstruction(context, begin)         ||
                tryInstructionBlock(context, begin)    ||
                tryInclude(context, begin)             ||
                tryVariableDeclaration(context, begin) ||
                tryOther(context);

        if (tmpRes === -1) {
            // parsing failed
            return "";
        }

        return tmpRes;
    }

    pkg.internals.parseStatement = parseStatement;
}((typeof exports !== "undefined" && exports) || (this.audescript = {}), this));
