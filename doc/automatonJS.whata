[set
   author   = Raphaël Jakse (raphael dot jakse at gmail dot com)
   title    = "AutomatonJS — Programming Language for automata"
   css      = whata.css \ geshi.css \ notes.css
]

[ =. Introduction
   AutomatonJS is a dedicated language. Its goal is easing the task of writing algorithms working on automata in a pedagogic and intuitive way. Of course, intuition is a rather personal element and two different persons can have different feelings on what they find intuitive or not, so trying to design an intuitive language that will please everybody might be a waste of time. Therefore, instead of just being intuitive, defining more precise directions to follow when designing the language should be a good start.

   So far, these directions were considered:
    # Do not reinvent everything. Instead, try to aggregate wonderful ideas to conceive a wonderful language. This has several advantage:
       # With a good probability, what exists was already deeply though by other people we can probably trust, so the idea is well-tried, ready for usage. By using other people ideas when they exist give them credit on their work and save your time for completely new, unexplored ideas.
       # If a way of doing things is already spread, people don't have to learn something new. While learning new things is great, be forced to learn a new programming language to do a specific task can make people give up the usage of the tool.
    # Close to the mathematics. Scientific students and scientists are in the target of the language and math is (should be, at least!) a familiar language through these people. Mathematical language is precise, clear and concise and algorithms on automaton are often described with mathematical notation.
    # Be explicit. No weird symbols, no weird idioms. Unfortunately, mathematical symbols can be difficult to handle while programming. However, ASCII art to represent them is not desirable. The code should be readable for newcomers and gessing sense of expressions of the language should be easy and reliable. [c <<<|_|>>>] and [c <<< /\>>>] for the union and the intersection operators can be hard to understand. "union" and "inter" are more likely to be understood at the first glance.

   In "do not reinvent everything", we have "do not reinvent a new language". More precisely, AutomatonJS is not really a new language: choice to base AutomatonJS on a already existant language was made, with these advantages in mind:
    - Real dedicated languages, by design, are limited. They have features their authors thought of and as time flies, successful dedicated languages tend to be generalist. Lets have a full-featured language which already has its community and its ecosystem.
    - Less work for more. An already existent language already has well-tried tools like interpreters, (JIT-)compilers, debuggers, editors, etc. and these tools have been made powerful by years.
    - If the community of the base language is already large, people will find documentation and help more easily and less people will have to learn a new language.

   The choice of the base language was taken with these points in mind:
    - relatively familiar syntax (close to C's) for most people
    - Great community
    - Great tools
    - Web-compatible, that is to say, easy to run in a browser.
    - Strong type handling, which is better for both pedagogic and debugging concerns.

   Based of these points, a language comes rapidly in mind: Javascript. Javascript is the only one language to run in browser natively and present browsers competitions imply constant enhancement of the language and the tools running it (engines, interpreters, JIT compilers, debuggers), their speed included. Its C-like syntax is also a great point.

   In fact, pure Javascript in its ECMAScript 6 version (still to be released) is very close to what seems to be needed to play with automata comfortably. What is still to add to the language is an Automaton class, a decent set handling and a better type handling: that's what is AutomatonJS for. Learning AutomatonJS is learning pure Javascript plus the few additions of AutomatonJS to Javascript. The base language of AutomatonJS is Javascript in its [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode | strict mode]][footnote https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode].

   Given that, the goal is to stay very close to Javascript and to add just what we need. However, except Firefox, browsers of nowadays still don't support ECMAScript 6. Unfortunately, unlike ECMAScript 6, older versions of ECMAScript are really lacking things. As a result, work has been done to support some ECMAScript 6 points even in non-ecmascript 6 browsers.

   In this documentation, differences between what is done when coding in pure Javascript and what should be done in AutomatonJS instead will be highlighted. This includes usage of some ECMAScript 6 subtleties. This documentation is not there to learn how to program. It is here to present the most important features of Javascript that should be known to program in AutomatonJS and to cover additions of AutomatonJS to Javascript and best practices to follow when programming in AutomatonJS.

   Let's go.
]

[newpage]

[ = Statements in Javascript
   Statements, in Javascript, are instructions or expression ended by a semicolon, or control flow statements (which don't end with a semicolon). Empty statements are also allowed, so e.g. writing a semicolon right after an [c if] statement is valid.
   
   The semicolon is often optional, so a end of line can replace entirely a semicolon. To see when the semicolon can be omitted, you can look at the [[http://www.ecma-international.org/ecma-262/5.1/#sec-7.9 | Section 7.9 of the ECMAScript 5.1 language specification]][footnote http://www.ecma-international.org/ecma-262/5.1/#sec-7.9].

   Statements can be grouped at any time with curly brackets. Thus, this is valid :
   [code=javascript <<<
      hello();
      
      {
         action(1);
         action(2);
         action(3);
      }
      
      hello(2);
   >>>]

   Curly brackets introducing a new scope, in browsers that support the [c let] keyword natively, these two following codes are equivalent:

   [code=javascript <<<
      let(i=2, d="hello") {
         console.log(d);
         ++i;
      }
      // i and d are undefined everywhere
   >>>]

   [code=javascript <<<
      {
         let i=2, d="hello";
         console.log(d);
         ++i;
      }
      // i and d are undefined in browser supporting let declarations
   >>>]

   Although the semicolon can be optional, I strongly advise you to always write it unless you really know what you are doing. This is particularly true in AutomatonJS, which sometimes rely on semicolons to make the difference between a set literal and a block of instructions.
]

[ = Declaring variables
   [ = The [c var] statement
      In Javascript, declaring variables is done with the [c var] keyword :
      [code=javascript <<<
         var v = "Hello world!";
      >>>]

      While this is possible is AutomatonJS, this is not advised. The [c let] keyword is preferred.
   ]
   [ = The [c let] statement
      [code=javascript <<<
         let v = "Hello world!";
      >>>]

      The [c let] keyword, when natively supported by the browser, acts differently than [c var]. The [c var] keyword define the variable at the function level :
      
      [code=javascript <<<
         let enstein = "a scientist";
         if(enstein) {
            var firstName = "albert"
         }
         else {
            var firstName = "roger";
         }
         alert(firstName); // shows "albert".
      >>>]
 
      On the contrary, [c let] works at block-level:
      [code=javascript <<<
         let enstein = "a scientist";
         if(enstein) {
            let firstName = "albert";
         }
         else {
            let firstName = "roger";
         }
         alert(firstName); // ERROR, firstName is not defined.
      >>>]

      [ = Current limitation
         In browsers that not support [c let] natively, [c let] acts like [c var]. That is to say, the previous code shows "albert" instead of issuing an error. As of Jully 2013, Firefox is the only browser to show the right behavior.
      ]
   ]
   
   [ = The [c let] expression
      The [c let] expression allows you to declare a variable inside a block.
      [code=javascript <<<
         let f = 5;

         let (i=2, d=3) {
            alert(i * d * f); // shows 30
            d = 0;
            f = 9;
            alert(d); // shows 0;
         }
         // f is still defined and is equal to 9
         // but i and d are not.
      >>>]

      [ = Current limitation
         In browsers that don't support the let expression natively, you cannot define things inside the [c let] expression and have it defined outside when going out the let block :
         [code=javascript <<<
            let f = 5;

            let (i=2, d=3) {
              var g = 2;
            }

            alert(g); // g is not defined in Chromium, but is equal to 2 in Firefox.
         >>>]

         Anyway, don't use the [c var] keyword. Use [c let] and don't define variable inside a block to have it define outside. Instead, write:

         [code=javascript <<<
            let f = 5;
            let g; // that where g should be defined anyway
            let (i=2, d=3) {
              g = 2;
            }

            alert(g); // this shows 2 everywhere.
         >>>]
      ]
   ]
   
   [ = Typed declaration
      This is a AutomatonJS specific way of defining variables and is the recommended way of doing things as it forces the developer not to change the type of variables.
      
      The syntax is the following :
      
      [code <<<
         variable_name : Type;
         variable_name : Type = initial_value;
         variable_name : Set of Type;
      >>>]
      
      Where Type is one of these case-insensitive keywords (keyword inside the same item list are equivalent):
       - String
       - Integer or int
       - Number or float
       - Boolean or bool
       - Set
       - Automaton
       - Object (native Javascript Object)
       - List, Table, Array
       - Function

       Additionally, Type can be any defined Javascript class. In this case, Type is case-sensitive.

      [ = Examples :

         [code=javascript <<<
            i : Integer;        // i is an integer initialized to 0;
            j : Integer = 2;    // j is an integer initialized to 2;
            d : Number;         // d is a number initialized to 0;
            l : List;           // l is a Javascript native Array.
            s : String;         // s is an empty string
            A : Automaton;      // A is an Automaton
            B : Set;            // B is a set which can contain anything
            C : Set of Integer; // C is a Set restricted to integers.
            D : Set of Set;     // D is a Set of Set            
         >>>]
      ]

      Typed declarations define variable in the block, not in the function, when let is natively supported by the browser. They behave exactly like the AutomatonJS [c let] keyword.

      [ = Current limitations
         The limitations are the same as for [c let] : the scope of definition is wrong in browsers which don't support the [c let] keyword natively.

         Moreover, constraint on sets of sets can't be fully writen with a typed declaration:
         [code=javascript <<<
            s : Set of Set of Integer; // this won't work
         >>>]
      ]
   ]

   [ = The [c const] statement
      The [c const] statement lets you define constants. It does exactly the same as the [c let] keyword, but forbids the modification of the defined variable.
      
      [code=javascript <<<
         const bestYear = 1993;
         
         bestYear = 1992; // TypeError: s is read-only
      >>>]
      
      [ = Current limitations
         [c const] defines constants at function level, like [c var], where it should define them at block level, like [c let]:
         [code=javascript <<<
            if(true) {
              const g = 2;
            }
            return g; // returns 2 instead of raising an error about g being undefined.
         >>>]
      ]
   ]
]

[ = Control flow statements
   Control flow statements let you structure your programs. They allow the execution or the repetition of a set of instructions under certain conditions and change the order of execution of the code in a logical way.

   In AutomatonJS, like in Javascript, conditions are surrounded by parenthesis and instructions can be grouped with curly brackets.
   Like in C, curly brackets can be omitted when a block of instructions is reduced to one instruction.

   [ = The [c if] / [c else] statement
      The [c if] statement look like the following:
      [code=javascript <<<
         if(condition) {
            // instructions to execute if condition is verified
         }
      >>>]
      With the [c else] part:
      [code=javascript <<<
         if(condition) {
            // instructions to execute  if condition is verified
         }
         else {
            // instructions to execute  if condition is not verified
         }
      >>>]

      There is no [c elseif] keyword. However, Javascript's syntax let you write things like:
      [code=javascript <<<
         if(whereToStudy === ujf) {
            res = "right decision";
         }
         else if(holidays) {
            res = "rest a little";
         }
         else if(student) {
            res = "stages are great";
         }
         else {
            res = "unhandled case";
         }
      >>>]
   ]
   
   [ = Loop statements
      [ = The [c while statement]
         The [c while] statement looks like the following:
         [code=javascript <<<
            while(condition) {
               // instuctions to execute while condition is true
            }
         >>>]
      ]
      
      [ = The [c do...while] statement
         The [c do...while] statement looks like the following:
         [code=javascript <<<
            do {
               // instructions executed one time, an then re-executed until condition is false
            }
            while(condition); // notice the semicolon here
         >>>]
      ]
      
      [ = The [c for] statement
         The [c for] statement looks like this:
         [code=javascript <<<
            for(initialisation ; condition ; iterationStatement) {
               // instruction to be executed while condition is true
               // iterationStatement after each iteration
               // initialisation is executed before entering the loop.
               // the scope of the initialisation is that of the body of the loop
            }
         >>>]
         
         Example:
         [code=javascript <<<
            let res = "";
            for(let line="I won't write crappy code anymore", i=0, count=100; i < count; ++i) {
               res += line + "\n";
            }
            // here: line, i and count are not defined
            return res;
         >>>]
      ]
      
      [ = The [c foreach] statement
         This is an AutomatonJS-specific structure. It let you iterate over sets and lists in a natural way.

         [code=javascript <<<
            res : String;
            foreach(e in [2,4,6,8,10]) {
               res += e.toString() + ' ';
            }
            // here, e is undefined
            alert(res); // shows "2 4 6 8 10 "
         >>>]
         
         [code=javascript <<<
            res : String = "H-Ways to greet somebody in English : ";
            foreach(e in {"hey", "hello", "hi"}) {
               res += e + ' ';
            }
            return res; // "H-Ways to greet somebody in English : hey hi hello "
         >>>]

         [ = Warning: do not modify the element of iteration
            Do not do that, it will break things or result in unexpected behaviors:
            [code=javascript <<<
               s : Set of Set = { [1,2] , [1, 4], [6, 5] };
               foreach(e in s) {
                  e.push(3);
               }
               return [s.toString(), s contains [1,2,3]];
            >>>]

            This code returns a couple : the string representation of the set and a boolean indicating whether [c <<< [1,2,3] >>>] belongs to the set.
            
            [c <<< [1,2,3] >>>] is present in the string representation of the set (and is indeed present in the set), but cannot be found.

            [code=javascript <<<
               s : Set of Set = { [1,2] , [1, 4], [6, 5] };
               foreach(e in s) {
                  e = [e[0], 0];
               }
               return [s.toString(), s contains [1,0]];
            >>>]

            Here, the set remains unchanged, as e was a ''reference'' to the successive elements of s and the assignation operator scratches this references instead of modifying the actual element of the set. This is also true for simple elements as numbers, strings, regular expressions, ... modifying them by an assignation breaks the reference and do not affect the parent.

            This works:
            [code=javascript <<<
               s : Set of Set = { {1,2} , {1, 4}, {6, 5} };
               foreach(e in s) {
                  e.add("hello");
               }
               return [s.toString(), s contains {1, 2, "hello"}];
            >>>]

            Because sets inside sets tell their parents about their modifications. But be very careful with this, as habits of modifying the element of iteration can rapidly be taken, even when this hurts.

            Please, don't modify the set or the list you are iterating on during the loop, this results in undefined behaviors, as in many languages:

            [code=javascript <<<
               s : List =  [1,2,3,4,5];
               r : Set;

               foreach(e in l) {
                 l.push(e+10);
                 r.add(e);
               } // infinite loop
               return r;
            >>>]
            Why should this loop be infinite...

            [code=javascript <<<
               s : Set =  {1,2,3,4,5};
               r : Set;

               foreach(e in s) {
                 s.add(e+10);
                 r.add(e);
               }
               return r; // returns {1,2,3,4,5}
            >>>]
            ...whereas this one should end ?
         ]
         
         [ = A mathematical way of writing some [c for] loops
            You can use [c foreach] to write some [c for] loops with a syntax closer to mathematics :
            
            [code=javascript <<<
               for(let i=1; i <= 10; ++i) {
                  console.log(i);
               }
            >>>]

            is exactly equivalent to, and is the generated code for:

            [code=javascript <<<
               foreach(i in {1,...,10}) {
                  console.log(i);
               }
            >>>]
            
            [ = Note
               As comprehensive sets are still not supported by AutomatonJS, [c {1,...,10}] is not a real set literal. As a result, you cannot write things like:
               [code <<<
                  s : Set = {1,...,10}; // this should be possible in the future, but is still a syntax error for the moment.
               >>>]
               You can only write [c {a,...,b}] sets in [c foreach] loops, with [c a] and [c b] being any number or integer variables.
            ]
         ]
         
         [ = Note
            If you prefer using [c of] instead of [c in], is  the [c foreach] construct it's up to you.
         ]
         
         [ = Current limitation
            Breaking to a specified label doesn't work in browser not natively supporting the [c for...of] structure. simple [c break] will however work as expected.
         ]
      ]
      
      [ = The [c for...in] statement
         The [c for...in] statement is a Javascript construction to iterate over indexes of lists or enumerable properties of objects.
         [code=javascript <<<
            res : String;
            l   : List =  [2,4,6,8,10];

            for(let i in l) {
               res += i + ': ' + l[i] + '\n';
            }
            return res;
            /* returns :
               "0: 2
                1: 4
                2: 6
                3: 8
                4: 10"
            */
         >>>]
         [ = Note
            - [c for...in] has not much sense on sets, as their elements have no indexes. Use [c foreach] or [c for...of] instead.
            - [
               if you need the index corresponding to the last iteration, declare the iteration variable before the loop :
               
               [code=javascript <<<
                  l   : List =  [2,4,6,8,10];
                  i   : Integer;
                  for(i in l) {
                     // do something here
                  }
                  return i; // returns 4
               >>>]
            ]
         ]
      ]

      [ = The [c for...of] statement
         The [c for...of] statement is a more complicated yet more flexible way to do what [c foreach] does. It is an ECMAScript 6 structure handled by AutomatonJS when browsers do not handle it themselves.
         The real difference between foreach and [c for...of] if that the iteration variable must be explicitly declared :
         [code=javascript <<<
            res : String;

            for(let i of [2,4,6,8]) {
               res += i + ' ';
            }
            return res;
         >>>]

         If you need to know what was the last iterated element in the loop, [c foreach] does not really help you. On the contrary, [c for...of], while probably less intuitive, let you do this in an elegant way:

         [code=javascript <<<
            res : String;

            i : integer;
            for(i of [2,4,6,8]) {
               res += i + ' ';
            }
            return i; // returns 8
         >>>]

         If you want to stay compatible with pure ECMAScript, use [c for..of] instead of [c foreach].

         [ = Current limitation
            Breaking to a specified label doesn't work in browser not natively supporting the [c for...of] structure. simple [c break] will however work as expected.
         ]

      ]
   ]
   [ = The [c break] statement
      [c break] lets you immediately get out of a loop even if the condition is true / if there are still instructions to execute:
      
      [code=javascript <<<
         res : String;
         foreach(i in [1,2,3,4,5]) {
            if(i === 3) {
               break;
            }
         }
         alert('done'); // shows 'done'
         return res; // returns "1 2 "
      >>>]
   ]
   
   [ = The [c continue] statement
      [c continue] lets you jump to the next iteration, or get out of the current loop if no iterations remain, without executing the rest of the current iteration's instructions:

      [code=javascript <<<
         res : String;
         foreach(i in [1,2,3,4,5]) {
            if(i === 3) {
               continue;
            }
            res += i + ' ';
         }
         return res; // returns "1 2 4 5 ", note the missing 3.
      >>>]
   ]
   
   [ = The [c return] statement
      [c return] lets you leave the current function, or program, leaving a value at the same time. You can return everywhere in your program or your function, even in a loop.
      
      [code=javascript <<<
         function hello() {
            while(true) {
               return "world";
            }
         }
         
         return "hello " + hello() + '.'; // returns "hello world."
      >>>]
   ]
]

[ = [c function] statements
   Functions are fundamental to write and structure good non trivial programs. In Javascript, you can define functions at anytime (e.g. functions can be nested and can be defined in loops or if-else statements). They can take arguments and can call themselves.
   
   Here is an implementation of the factorial:
   [code=javascript <<<
      function fact(n) {
        if(n < 2) {
          return 1;
        }
        return n * fact(n-1);
      }

      return fact(6); // calling fact with 6. returns 720.
   >>>]

   If a function takes more than one arguments, they are separated with commas.

   [code=javascript <<<
      function sameParity(a,b) {
        return a % 2 === b % 2;
      }

      return sameParity(6, 2); // returns true.
   >>>]

   Functions have access to the variable of the scope in which they were defined:
   
   [code=javascript <<<
      women : Set = {"Marie Curie", "Sophie Germain", "Rita Levi"};
      function isAWoman(p) {
        return women contains p;
      }

      return isAWoman("Marie Curie"); // returns true.
   >>>]
]

[ = Literals
   In AutomatonJS, literals are the same as Javascript, plus sets.
   Briefly, we have numbers, strings, objects, arrays, regular expressions and functions.

   An important thing to notice is that AutomatonJS supports abbreviated Javascript 1.8 functions.
   [ = Javascript literals
      [code=javascript <<<
         // strings
            let str1 = "I'm a string";
            let str2 = 'I\'m another string';
            let str3 = 'I end with a new line and contain a \u0253 special character\n';
            let character = str3[2]; // character equals "e" and is also a string

         // numbers
            let i = 0; // zarro
            let answer = 14.5; // floating point
            let color  = 0xFF; // hexa
            let speedOfLight  = 3e10; // 300000000
            let notANumber = NaN;
            let inf = Infinity;
            let negInf = -Infinity;

         // objects
            let o = {}; // an empty object
            let idCard = {
               firstName: "Arthur",
               lastName:  "Dent",
               age:32
            };
            
            idCard.eyeColors = 'blue';

            let stillAnObject = null;
            
            alert(typeof stillAnObject); // shows "object"
         // arrays
            let a = []; // empy arrays
            let primeNumbers = [2,3,5,7,11,13];
            primeNumbers.push(17);
            let secondValue = primeNumbers[2];

         // regular expressions
            let r = /(?:http|ftp)s?:\/\/www\.[a-zA-Z]+[a-zA-Z0-9\.]*\/[\s\S]+/g;

         /* functions */
            // classic function

               let f = function(x) {
                  return 2 * x;
               };

               alert(f(2)); // 4

            // abbreviated 1-argument function
            
               let square = x => x*x;

               alert(square(10)); // 100
            
            let quadraticValue = (a,b,c,x) => a*x*x + b*x + c;
            alert(quadraticValue(2,3,4,5)); // 69
            
            let add1 = function(x) x+1;
            
            alert(add1(2)); // 3
      >>>]
      For more information about Javascript literals, you can look at [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals || MDN's Values, variables, and literals]][footnote https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals] or the ECMAScript documentation.
      For regular expressions, you can refer to [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions]][footnote https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions].
   ]

   [ = Set literals
      AutomatonJS has built-in support for sets and has a dedicated a dedicated literal to represent it.

      A set literal starts with a open curly bracket ([c {]), ends with a close curly bracket ([c }]) and contains one or more values separated with commas.

      We could have represented the empty set by something like [c {}] but it would have been ambiguous with empty Javascript objects. Instead, the [c emptySet] keyword represent an empty set.

      Examples:

      [code=javascript <<<
         let firstPrimeNumbers = {2,3,5,7};
         alert(firstPrimeNumbers contains 3); // true

         let e = emptySet;
         alert(e.card()); // 0

         typingEvenEmptySetIsMuchBetter : Set;
         
         IfYouKnowSetOfWhat : Set of Integer;

         meals : Set of String = {"breakfast", "lunch", "dinner"};
         
         anything : Set = {14, 38.5, "green"};

         singleton = {1};
         
         thisIsNotASet = {}; // this is an object.
         
         // Typed declarations transform objects and lists into sets
         ThisIsASet : Set = {};
         AnotherSet : Set = [1,2,3,4];
      >>>]
   ]
]

[ = Operators
   AutomatonJS understands every Javascript operator and adds several operators on sets.
   
   [p Important Note. | AutomatonJS changes the signification of the [c > == ] equality operator. See hereinafter.]

   [ = JavaScript operators

      [ = Arithmetic operators    
         |= Expression  |= Signification
         | [c a + b]    | The sum of [c a] and [c b]
         | [c a - b]    | The difference of [c a] by [c b]
         | [c a / b]    | The division of [c a] by [c b]
         | [c a * b]    | The multiplication of [c a] and [c b]
         | [c a % b]    | [c a] modulo [c b] (the reminder of the integer division of [c a] by [c b])
      ]

      [ = Bitwise operators
         |= Expression    |= Signification
         | [c a  & b]     | [c a] AND [c b]
         | [c a ~| b]     | [c a] OR  [c b]
         | [c a ^ b]      | [c a] XOR [c b]
         | [c > a  << n]  | Left shift. Shifts [c a] in binary representation [c n] (< 32) bits to the left, shifting in zeros from the right.
         | [c > a  >> n]  | Right shift. Shifts [c a] in binary representation [c n] (< 32) bits to the left, shifting in zeros from the right.
         | [c > a >>> n]  | Shifts [c a] in binary representation [c n] (< 32) bits to the right, discarding bits shifted off, and shifting in zeros from the left.

         For more information about bitwise operators, you might want to read the Bitwise Operators page of MDN where the last three lines of this table come from: ([[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators]]).
      ]

      [ = Assigning counterparts of these operators
         Let [c [b op]] be one of the operators hereinbefore. [c a [b op]= b] means [c a = a [b op] b].

         Example:

            [code=javascript <<<
               a : integer = 14;
               a += 3;
               alert(a); // shows 17
            >>>]

         Moreover, if a is a number,
         - [c ++a] increments [c a] by 1 and returns the new value of [c a];
         - [c a++] increments [c a] by 1 and returns the old value of [c a].
      ]

      [ = Comparison operators
         |= Expression  |= Signification
         | [c a <  b]   | true iff [c a] greater than and not equal to [c b]
         | [c a <= b]   | true iff [c a] greater than or equal to [c b]
         | [c a >  b]   | true iff [c a] lower than and not equal to [c b]
         | [c a === b]  | [c true]  iff [c a] is exactly the same object than [c b]
         | [c a !== b]  | [c false] iff [c a] is exactly the same object than [c b]

         In AutomatonJS, the meaning of the operators [c > ==] and [c > !=] has been changed. The meaning of equality operator is discussed hereinafter.
      ]
      
      [ = Boolean operators
         |= Expression  |= Signification
         | [c !a]     | if the boolean evaluation of [c a] is [c true], then [c false], otherwise [c true].
         | [c a || b] | if the boolean evaluation of [c a] is true, then [c a], otherwise [c b][footnote This different in C, where the meaning of the operator is the following: if the boolean evaluation of [c a] is [c true], then [c true], otherwise the boolean expression of [c b].]. This operator is lazy, that is to say if [c a] evaluates to [c true], [c b] is not evaluated.
         | [c a && b] | if the boolean evaluations of [c a] and [c b] are both [c true], then [c true], otherwise [c false].
         
         [ = Which expressions evaluates to [c true] / [c false] ?

            |= Expression               |= Boolean evaluation
            | [c false]                 | [c false]
            | [c ""]                    | [c false]
            | [c 0]                     | [c false]
            | [c NaN]                   | [c false]
            | [c {}]                    | [c true]
            | Any non empty string      | [c true]
            | Any number not equal to 0 | [c true]
            | Any set, even empty       | [c true]
            | Infinity, -Infinity       | [c true]
            | Any other object          | [c true]
         ]
      ]
   ]

   [ = Meaning of the equality operators
      In Javascript, there are to equality operator: [c > ==] and [c > ===] (and their negative variant, [c > !=] and [c > !==]).

      Both operators act the same way, except for comparisons between string and numbers. Let [c a] be a string and [c b] a number.
       - [c > a === b] and [c > b === a] both evaluate to [c false], for any [c a] and [c b].
       - [c > a == b] and [c > b == a]   evaluate to true if the string representation of [c b] is [c a].

      For the other cases, these operators are equivalent:
       - if [c a] and [c b] are the same string, [c a == b]
       - if [c a] and [c b] are the same number, [c a == b]
       - if [c a] and [c b] are the same regular expression, [c a == b].
       - [c null  == null]
       - [c true  == true]
       - [c false == false]
       - [c NaN   != NaN]
       - if [c a] and [c b] [** point] to the same object, [c a == b].

       However, if [c a] and [c b] are point to distinct objects, [c a !== b] even if [c a] and [c b] are equivalent. For example:
       [code=javascript <<<
          alert({1,2,3,4,5} === {1,2,3,4,5}); // Shows false, because two distinct objects are created.
       >>>]

       This is an important concern in Javascript, as we need to be able to check the equality between objects, in particular sets. AutomatonJS, as a consequence, changes the meaning of the [c > ==] operator, to be able to check equality between to distincts objects.

       In AutomatonJS, we have:
       [code=javascript <<<
          alert({1,2,3,4,5} === {1,2,3,4,5}); // false, because two distinct objects are created.

          alert({1,2,3,4,5} == {1,2,3,4,5}); // true, like one would expect.

          alert(new Objet == new Object); // true.
       >>>]

       Whereas [c new Objet != new Object] in pure Javascript.

       [p Note. | The [c > ===] and [c > !==] operators remain unchanged.]
   ]

   [ = Set operators
      In addition to the modified [c ==] and [c !=] operators, AutomatonJS defines new operators. In the following table, [c A] and [c B] refer to two sets, or objects that can be turned into sets like objects or lists. [c e ] is any possible value.
      
      |= Expression | =Signification
      | [A  union  B]         | The union of A and B
      | [A  inter  B]         | The intersection of A and B
      | [A  minus  B]         | The difference of A by B
      | [A symDiff B]         | The symetric difference of A and B
      | [ [c A contains e]
          [c A    has   e]
          [c e belongsTo A] ] | [c true] iff [c e] is inside [c A]

      [ = Assigning counterparts of [c union], [c inter] and [c minus]

         |= Expression     |= Signification
         | [c A union = B] | [div
                               - Assign the union of A and B to A.
                               - More efficient than [c A = A union B].
                               - Strictly equivalent to [c A.unionInPlace(B);].
                             ]
         | [c A inter = B] | [div
                               - Assign the intersection of A and B to A
                               - More efficient than [c A = A  inter  B].
                               - Strictly equivalent to [c A.interInPlace(B);].
                             ]
         | [c A minus = B] | [div
                               - Assign the difference of A by B to A
                               - More efficient than [c A = A  minus  B].
                               - Strictly equivalent to [c A.minusInPlace(B);].
                             ]

         [p Warning. | These operator exist for the sake of consistence with Javascript-native assigning operators. Before using assigning counterparts of set operators, please double check you visually prefer them to there equivalent expression. Triple check that your audience won't be lost with these operators if your code targets a particular audience (e.g. students).]
      ]
   ]
]

[ =. Conclusion
   This document tries to remain complete on additions of and differences between AutomatonJS to / and Javascript. This is far from covering all the language. For more information, you might want to read things on Javascript keeping differences covered here in mind.

   [ =. Ideas for the future
   - comprehensive sets like [c <<<{2k+1 | k in N}>>>] would be awesome.
   - Great ideas can be found here :
       - [[http://koush.com/post/yield-await-v8]]
       - [[http://mdn.beonex.com/en/JavaScript/New_in_JavaScript/1.7.html]], in particular :
          - ``yeld``, to make generators
          - the destructuring assignment
          - array comprehensions (Python-lovers will appreciate)
          - The [c let] statement: [[http://mdn.beonex.com/en/JavaScript/Reference/Statements/let.html]].
   ]
]